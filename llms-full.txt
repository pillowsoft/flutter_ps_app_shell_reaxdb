# Flutter App Shell - Complete Documentation

> A comprehensive Flutter application framework for rapid development with adaptive UI, service architecture, state management, and cloud synchronization capabilities. This document contains the complete framework documentation optimized for large language model consumption.

## Framework Overview

Flutter App Shell provides a zero-configuration foundation for Flutter applications with:

- **Service-Oriented Architecture**: Dependency injection with GetIt, reactive services, health monitoring
- **Adaptive UI System**: Complete runtime switching between Material, Cupertino, and ForUI design systems
- **Reactive State Management**: Signals-based reactivity with granular UI updates and automatic persistence
- **Responsive Navigation**: Automatic layout adaptation (bottom tabs â†’ navigation rail â†’ sidebar)
- **Offline-First Data**: Local Isar database with automatic Supabase cloud sync and conflict resolution
- **30+ Built-in Services**: Authentication, database, networking, file storage, preferences, and more

---

## Documentation Index

*Complete navigation hub for all Flutter App Shell documentation*

# Flutter App Shell Documentation

Welcome to the comprehensive documentation for Flutter App Shell - a powerful framework for rapid Flutter development with adaptive UI, service architecture, and cloud integration.

## ğŸ“š Documentation Index

### Getting Started
- [Getting Started Guide](getting-started.md) - Step-by-step tutorial for your first app
- [Installation & Setup](installation.md) - Detailed installation instructions
- [Quick Start Examples](quickstart-examples.md) - Common use cases and code snippets

### AI-Friendly Documentation
- **[llms.txt](../llms.txt)** - Navigation index optimized for AI consumption ([llms.txt spec](https://llmstxt.org))
- **[llms-full.txt](../llms-full.txt)** - Complete documentation for AI development
- **[Generate llms.txt](#generating-llmstxt-files)** - Instructions for updating AI-friendly docs

### Core Concepts
- [Architecture Overview](architecture.md) - Framework architecture and design principles
- [Service Layer](services/README.md) - Understanding the service-oriented architecture
- [State Management](state-management.md) - Signals-first reactive state management
- [Navigation System](navigation.md) - Responsive navigation and routing

### UI & Design Systems
- [Adaptive UI Overview](ui-systems/README.md) - Complete guide to adaptive UI systems
- [Material Design](ui-systems/material.md) - Material Design implementation
- [Cupertino (iOS)](ui-systems/cupertino.md) - iOS-style components and behavior
- [ForUI](ui-systems/forui.md) - Modern minimal design system
- [Component Library](ui-systems/components.md) - Complete component reference

### Services Documentation
- [Services Overview](services/README.md) - All available services
- [Database Service](services/database.md) - Local storage with cloud sync
- [Authentication Service](services/authentication.md) - User authentication and management
- [Network Service](services/networking.md) - HTTP client with offline support
- [File Storage Service](services/file-storage.md) - Local and cloud file management
- [Preferences Service](services/preferences.md) - Settings and user preferences
- [Navigation Service](services/navigation.md) - Centralized navigation management
- [Service Inspector](services/inspector.md) - Real-time debugging and monitoring

### Cloud Integration
- [InstantDB Integration](cloud/instantdb.md) - Complete InstantDB setup and usage
- [Offline-First Architecture](cloud/offline-first.md) - Local-first with cloud sync
- [Real-time Features](cloud/realtime.md) - Live updates and subscriptions
- [Conflict Resolution](cloud/conflict-resolution.md) - Handling concurrent modifications

### Plugin System
- [Plugin System Overview](plugin-system.md) - Comprehensive plugin architecture
- [Creating Plugins](plugins/creating-plugins.md) - Plugin development guide
- [Service Plugins](plugins/service-plugins.md) - Business logic extensions
- [Widget Plugins](plugins/widget-plugins.md) - UI component extensions
- [Theme Plugins](plugins/theme-plugins.md) - Custom UI systems
- [Workflow Plugins](plugins/workflow-plugins.md) - Automation and processing

### Advanced Topics
- [Custom Services](advanced/custom-services.md) - Creating your own services
- [Extending the Framework](advanced/extending.md) - Adding new functionality
- [Performance Optimization](advanced/performance.md) - Best practices for performance
- [Testing Strategies](advanced/testing.md) - Testing framework components

### Examples & Patterns
- [Common Patterns](examples/patterns.md) - Recommended implementation patterns
- [Real-world Examples](examples/real-world.md) - Complete example applications
- [Code Snippets](examples/snippets.md) - Useful code snippets and utilities
- [Migration Examples](examples/migration.md) - Migrating existing apps

### Reference
- [API Reference](api/README.md) - Complete API documentation
- [Configuration Options](reference/configuration.md) - All configuration options
- [Environment Variables](reference/environment.md) - Environment configuration
- [Troubleshooting](reference/troubleshooting.md) - Common issues and solutions

### Contributing
- [Contributing Guide](contributing/README.md) - How to contribute to the framework
- [Development Setup](contributing/development.md) - Setting up development environment
- [Code Standards](contributing/standards.md) - Coding standards and conventions

## ğŸš€ Quick Navigation

### New to Flutter App Shell?
1. [Getting Started Guide](getting-started.md)
2. [Architecture Overview](architecture.md)
3. [Quick Start Examples](quickstart-examples.md)

### Building Your First App?
1. [Installation & Setup](installation.md)
2. [Basic App Structure](examples/basic-app.md)
3. [Adding Services](services/README.md)

### Looking for Specific Features?
- **Adaptive UI**: [UI Systems Guide](ui-systems/README.md)
- **Database**: [Database Service](services/database.md)
- **Authentication**: [Authentication Service](services/authentication.md)
- **Cloud Sync**: [InstantDB Integration](cloud/instantdb.md)
- **Navigation**: [Navigation System](navigation.md)
- **Plugins**: [Plugin System](plugin-system.md)

### Need Help?
- [Troubleshooting Guide](reference/troubleshooting.md)
- [FAQ](reference/faq.md)
- [Community Support](contributing/support.md)

## ğŸ“– Documentation Format

This documentation uses the following conventions:

- **ğŸ’¡ Tips** - Helpful hints and best practices
- **âš ï¸ Important** - Critical information and warnings
- **ğŸ“ Examples** - Code examples and implementations
- **ğŸ”— References** - Links to related documentation

## ğŸ¤– Generating llms.txt Files

Flutter App Shell includes an AI-friendly documentation format called [llms.txt](https://llmstxt.org) that makes it easy for large language models to understand and use the framework.

### What are llms.txt files?

- **`llms.txt`** - Navigation index optimized for AI consumption
- **`llms-full.txt`** - Complete documentation content for comprehensive AI understanding

### Generating llms.txt Files

Use the built-in Dart CLI tool to generate updated llms.txt files:

```bash
# Generate llms.txt files (requires Dart SDK)
just generate-llms

# Or build the generator and run it
just setup-llms

# Manual generation with custom options
./generate_llms_txt --verbose --docs-dir docs --output-dir .
```

### Using llms.txt for AI Development

Share the `llms.txt` or `llms-full.txt` files with AI assistants like Claude, ChatGPT, or others to help them understand the Flutter App Shell framework and assist with development.

**Example prompt:**
```
I'm working with Flutter App Shell. Here's the complete documentation:

[Paste contents of llms-full.txt here]

Please help me create a new app with authentication and a todo list.
```

### Keeping llms.txt Updated

The llms.txt files are automatically generated from the markdown documentation in the `docs/` directory. When you update documentation:

1. Make changes to the relevant `.md` files in `docs/`
2. Run `just generate-llms` to update the llms.txt files
3. Commit both the documentation changes and updated llms.txt files

## ğŸ¤ Contributing to Documentation

Found an error or want to improve the documentation? See our [Contributing Guide](contributing/README.md) for details on how to help make this documentation better.

---

*Last updated: 2025-08-10*

---

## Getting Started Guide

*Step-by-step tutorial to build your first app in 5-10 minutes*

# Getting Started with Flutter App Shell

Welcome! This guide will help you create your first Flutter App Shell application in just a few minutes. Flutter App Shell is designed to get you from zero to a fully-featured app with minimal boilerplate.

## ğŸ¯ What You'll Build

By the end of this guide, you'll have a complete Flutter app with:
- âœ… Adaptive UI that works on mobile, tablet, and desktop
- âœ… Navigation system that automatically adjusts to screen size
- âœ… Settings persistence and theme switching
- âœ… Multiple services ready for your business logic
- âœ… Service inspector for debugging
- âœ… Plugin system for extending capabilities

**Estimated time: 5-10 minutes**

## ğŸ“‹ Prerequisites

- Flutter SDK 3.16.0 or higher
- Dart 3.0 or higher
- Your favorite code editor (VS Code, Android Studio, etc.)

## ğŸš€ Step 1: Create Your Project

### Option A: Clone the Framework
```bash
git clone https://github.com/your-org/flutter_ps_app_shell.git my_app
cd my_app
flutter pub get
```

### Option B: Add as Dependency
```bash
flutter create my_app
cd my_app
```

Add to your `pubspec.yaml`:
```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_app_shell:
    git:
      url: https://github.com/your-org/flutter_ps_app_shell.git
      path: packages/flutter_app_shell
```

```bash
flutter pub get
```

## ğŸ—ï¸ Step 2: Basic App Setup

Replace your `lib/main.dart` with this minimal setup:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_app_shell/flutter_app_shell.dart';

void main() {
  runShellApp(() async {
    return AppConfig(
      title: 'My First App Shell App',
      routes: [
        AppRoute(
          title: 'Home',
          path: '/',
          icon: Icons.home,
          builder: (context, state) => const HomeScreen(),
        ),
        AppRoute(
          title: 'Profile',
          path: '/profile',
          icon: Icons.person,
          builder: (context, state) => const ProfileScreen(),
        ),
        AppRoute(
          title: 'Settings',
          path: '/settings',
          icon: Icons.settings,
          builder: (context, state) => const AppShellSettingsScreen(),
        ),
      ],
    );
  });
}

class HomeScreen extends StatelessWidget {
  const HomeScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final ui = getAdaptiveFactory(context);
    final styles = context.adaptiveStyle;
    
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.rocket_launch,
            size: 64,
            color: styles.primaryColor,
          ),
          const SizedBox(height: 24),
          Text(
            'Welcome to Flutter App Shell!',
            style: styles.headlineStyle,
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 16),
          Text(
            'Your app is ready to go with adaptive UI,\nservices, and navigation.',
            style: styles.bodyStyle,
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 32),
          ui.button(
            label: 'Get Started',
            onPressed: () {
              getIt<NavigationService>().goToPath('/profile');
            },
          ),
        ],
      ),
    );
  }
}

class ProfileScreen extends StatelessWidget {
  const ProfileScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final ui = getAdaptiveFactory(context);
    final styles = context.adaptiveStyle;
    
    return Padding(
      padding: const EdgeInsets.all(24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'User Profile',
            style: styles.headlineStyle,
          ),
          const SizedBox(height: 24),
          ui.listSection(
            header: const Text('Personal Information'),
            children: [
              ui.listTile(
                title: const Text('Name'),
                subtitle: const Text('John Doe'),
                leading: const Icon(Icons.person),
              ),
              ui.listTile(
                title: const Text('Email'),
                subtitle: const Text('john.doe@example.com'),
                leading: const Icon(Icons.email),
              ),
            ],
          ),
          const SizedBox(height: 24),
          ui.button(
            label: 'Edit Profile',
            onPressed: () {
              ui.showSnackBar(
                context: context,
                content: const Text('Edit functionality coming soon!'),
              );
            },
          ),
        ],
      ),
    );
  }
}
```

## ğŸ¨ Step 3: Run Your App

```bash
flutter run
```

ğŸ‰ **Congratulations!** You now have a working Flutter App Shell application with:

- **Adaptive navigation** that automatically switches between bottom tabs, navigation rail, and sidebar based on screen size
- **Three different screens** demonstrating various UI components
- **Settings screen** with theme switching and UI system selection
- **Responsive design** that works on mobile, tablet, and desktop

## ğŸ§ª Step 4: Explore the Features

### Try Different UI Systems
1. Go to the Settings tab
2. Switch between Material, Cupertino, and ForUI
3. Notice how the entire app adapts its visual style

### Test Responsive Behavior
1. Resize your app window (on desktop)
2. Watch the navigation automatically adapt:
   - **Small**: Bottom tabs
   - **Medium**: Navigation rail
   - **Large**: Full sidebar

### Check Settings Persistence
1. Change theme mode (Light/Dark/System)
2. Switch UI systems
3. Restart your app - settings are automatically saved!

## ğŸ”§ Step 5: Add Your First Service

Let's add a simple data service to demonstrate the service architecture:

```dart
// lib/services/todo_service.dart
import 'package:flutter_app_shell/flutter_app_shell.dart';

class TodoService {
  static TodoService? _instance;
  static TodoService get instance => _instance ??= TodoService._();
  TodoService._();

  final List<Todo> _todos = [];
  final _todosSignal = ListSignal<Todo>([]);

  List<Todo> get todos => _todosSignal.value;
  ListSignal<Todo> get todosSignal => _todosSignal;

  void addTodo(String title) {
    final todo = Todo(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      title: title,
      completed: false,
    );
    _todos.add(todo);
    _todosSignal.value = List.from(_todos);
  }

  void toggleTodo(String id) {
    final index = _todos.indexWhere((todo) => todo.id == id);
    if (index != -1) {
      _todos[index] = _todos[index].copyWith(completed: !_todos[index].completed);
      _todosSignal.value = List.from(_todos);
    }
  }
}

class Todo {
  final String id;
  final String title;
  final bool completed;

  Todo({required this.id, required this.title, required this.completed});

  Todo copyWith({String? title, bool? completed}) {
    return Todo(
      id: id,
      title: title ?? this.title,
      completed: completed ?? this.completed,
    );
  }
}
```

Register the service in your `main.dart`:

```dart
void main() {
  runShellApp(() async {
    // Register your custom service
    getIt.registerSingleton<TodoService>(TodoService.instance);
    
    return AppConfig(
      // ... rest of your config
    );
  });
}
```

## ğŸ¯ What's Next?

Now that you have a basic app running, here are some next steps:

### ğŸ“š Learn More
- [Architecture Overview](architecture.md) - Understand how everything works together
- [UI Systems Guide](ui-systems/README.md) - Deep dive into adaptive UI
- [Services Documentation](services/README.md) - Explore all available services

### ğŸ”§ Add Features
- [Database Service](services/database.md) - Add local storage with cloud sync
- [Authentication](services/authentication.md) - Add user authentication
- [File Storage](services/file-storage.md) - Handle file uploads and downloads

### ğŸŒŸ Advanced Topics
- [Custom Services](advanced/custom-services.md) - Create your own services
- [Cloud Integration](cloud/instantdb.md) - Add InstantDB for real-time features
- [Performance](advanced/performance.md) - Optimize your app

## ğŸ’¡ Tips for Success

### 1. Use the Service Inspector
The Service Inspector is your best friend for debugging. Access it through the settings screen or add it as a route:

```dart
AppRoute(
  title: 'Inspector',
  path: '/inspector',
  icon: Icons.bug_report,
  builder: (context, state) => const ServiceInspectorScreen(),
),
```

### 2. Follow the Adaptive Pattern
Always use the adaptive factory for UI components:

```dart
// âœ… Good - Adaptive
final ui = getAdaptiveFactory(context);
ui.button(label: 'Click me', onPressed: () {});

// âŒ Bad - Platform-specific
ElevatedButton(onPressed: () {}, child: Text('Click me'));
```

### 3. Use Signals for State
Leverage the reactive state management:

```dart
final counter = signal(0);

// In your widget
Watch((context) => Text('Count: ${counter.value}'))

// Update anywhere
counter.value++;
```

### 4. Leverage Settings Persistence
User preferences are automatically saved:

```dart
final settings = getIt<AppShellSettingsStore>();
settings.uiSystem.value = 'cupertino'; // Automatically persisted
```

## ğŸ”Œ Step 7: Using Plugins (Optional)

Flutter App Shell supports plugins to extend functionality:

```dart
import 'package:flutter_app_shell/flutter_app_shell.dart';

void main() {
  // Create or import plugins
  final analyticsPlugin = AnalyticsPlugin();
  final chartPlugin = ChartWidgetPlugin();
  
  runShellApp(
    () async => AppConfig(
      title: 'My App with Plugins',
      routes: [...],
    ),
    enablePlugins: true,
    pluginConfiguration: {
      'manualPlugins': [analyticsPlugin, chartPlugin],
    },
  );
}

// Use plugin services
final analytics = getIt<AnalyticsService>();
await analytics.trackEvent('app_started');
```

### Plugin Types Available:
- **Service Plugins**: Add business logic services (analytics, payment, etc.)
- **Widget Plugins**: Custom UI components that adapt to all UI systems
- **Theme Plugins**: Create completely custom UI systems
- **Workflow Plugins**: Automation and background processing

Learn more about plugins in the [Plugin System documentation](plugin-system.md).

## ğŸ†˜ Getting Help

- **Documentation**: Browse the [full documentation](README.md)
- **Plugin System**: Learn about [extending with plugins](plugin-system.md)
- **Examples**: Check out the [example app](../example/) for more complex usage
- **Issues**: Report bugs on [GitHub Issues](https://github.com/your-org/flutter_ps_app_shell/issues)
- **Troubleshooting**: See the [troubleshooting guide](reference/troubleshooting.md)

## ğŸ‰ You're Ready!

You now have a solid foundation with Flutter App Shell. The framework handles the boilerplate so you can focus on building your app's unique features. Happy coding! ğŸš€

---

**Next:** [Architecture Overview](architecture.md) to understand how everything works together.

---

## Architecture Overview

*Service-oriented architecture, adaptive UI, and reactive state management principles*

# Architecture Overview

Flutter App Shell is built with a clean, modular architecture that separates concerns and makes your app scalable, testable, and maintainable. This guide explains the core architectural principles and how everything fits together.

## ğŸ—ï¸ Core Architecture Principles

### 1. Service-Oriented Architecture (SOA)
All business logic lives in services that are:
- **Singleton instances** managed by GetIt dependency injection
- **Loosely coupled** with clear interfaces
- **Independently testable** with mock implementations
- **Reactive** using Signals for state updates

### 2. Adaptive UI System
The UI layer adapts to different design systems:
- **Abstract factory pattern** for platform-agnostic components
- **Runtime switching** between Material, Cupertino, and ForUI
- **Responsive layouts** that adapt to screen size
- **Consistent API** across all platforms

### 3. Reactive State Management
State flows through the app using:
- **Signals** as the primary reactive primitive
- **Watch widgets** for automatic UI updates
- **Immutable state** for predictable behavior
- **Granular reactivity** for optimal performance

### 4. Plugin System Architecture
Extensible framework through plugins:
- **Four plugin types** for different extension needs
- **Auto-discovery** from dependencies and directories
- **Dependency resolution** with automatic loading order
- **Type-safe contracts** for all plugin interactions
- **Health monitoring** and real-time status tracking

## ğŸ“ High-Level Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Plugin Extension Layer                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Service Plugins     â”‚  Widget Plugins      â”‚  Theme/Work  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Analytics       â”‚  â”‚  â”‚ Charts          â”‚  â”‚ â”‚ Custom   â”‚ â”‚
â”‚  â”‚ Payment         â”‚  â”‚  â”‚ Rich Editors    â”‚  â”‚ â”‚ Themes   â”‚ â”‚
â”‚  â”‚ Custom APIs     â”‚  â”‚  â”‚ Media Players   â”‚  â”‚ â”‚ Workflowsâ”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      Presentation Layer                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Adaptive UI System  â”‚  Screens & Widgets  â”‚  Navigation   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Material        â”‚  â”‚  â”‚ Home Screen     â”‚ â”‚ â”‚ GoRouter â”‚  â”‚
â”‚  â”‚ Cupertino       â”‚  â”‚  â”‚ Settings Screen â”‚ â”‚ â”‚ Responsiveâ”‚  â”‚
â”‚  â”‚ ForUI           â”‚  â”‚  â”‚ Profile Screen  â”‚ â”‚ â”‚ Layout   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      Business Logic Layer                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  State Management    â”‚      Services         â”‚  Plugin Mgr  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Signals         â”‚  â”‚  â”‚ DatabaseService â”‚  â”‚ â”‚ Manager  â”‚ â”‚
â”‚  â”‚ Watch Widgets   â”‚  â”‚  â”‚ AuthService     â”‚  â”‚ â”‚ Registry â”‚ â”‚
â”‚  â”‚ Settings Store  â”‚  â”‚  â”‚ NetworkService  â”‚  â”‚ â”‚ Discoveryâ”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚ PrefsService    â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                       â”‚  â”‚ NavigationSvc   â”‚  â”‚              â”‚
â”‚                       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        Data Layer                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Local Storage      â”‚    Cloud Services     â”‚   Models     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ InstantDB NoSQL â”‚  â”‚  â”‚ InstantDB       â”‚  â”‚ â”‚ Data     â”‚ â”‚
â”‚  â”‚ SharedPrefs     â”‚  â”‚  â”‚ Real-time Sync  â”‚  â”‚ â”‚ Models   â”‚ â”‚
â”‚  â”‚ File System     â”‚  â”‚  â”‚ WebSockets      â”‚  â”‚ â”‚ DTOs     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ Core Components

### Service Locator (GetIt)
The backbone of dependency injection:

```dart
// Registration (happens in runShellApp)
getIt.registerSingleton<DatabaseService>(DatabaseService.instance);
getIt.registerSingleton<AuthenticationService>(AuthenticationService.instance);

// Access anywhere in your app
final db = getIt<DatabaseService>();
final auth = getIt<AuthenticationService>();
```

**Benefits:**
- âœ… Testable (easy to mock services)
- âœ… Loosely coupled components
- âœ… Clear dependency management
- âœ… Singleton lifecycle management

### Adaptive Widget Factory
Abstracts UI implementation across platforms:

```dart
abstract class AdaptiveWidgetFactory {
  Widget button({required String label, required VoidCallback onPressed});
  Widget textField({String? label, ValueChanged<String>? onChanged});
  // ... 30+ adaptive widgets
}

// Implementations
class MaterialWidgetFactory extends AdaptiveWidgetFactory { /* ... */ }
class CupertinoWidgetFactory extends AdaptiveWidgetFactory { /* ... */ }
class ForUIWidgetFactory extends AdaptiveWidgetFactory { /* ... */ }
```

**Benefits:**
- âœ… Platform-agnostic UI code
- âœ… Runtime UI system switching
- âœ… Consistent component API
- âœ… Easy to extend with new systems

### Reactive State with Signals
Granular, efficient state management:

```dart
// Create reactive state
final counter = signal(0);
final user = signal<User?>(null);

// Computed values
final doubledCounter = computed(() => counter.value * 2);

// Watch for changes in UI
Watch((context) => Text('Count: ${counter.value}'))

// Effect for side effects
effect(() {
  print('Counter changed to: ${counter.value}');
});
```

**Benefits:**
- âœ… Granular reactivity (only affected widgets rebuild)
- âœ… No boilerplate (no setState, notifiers, etc.)
- âœ… Computed values and effects
- âœ… Excellent debugging story

## ğŸ—‚ï¸ Project Structure

```
lib/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ core/                   # Core framework components
â”‚   â”‚   â”œâ”€â”€ app_config.dart     # App configuration
â”‚   â”‚   â”œâ”€â”€ app_route.dart      # Route definitions
â”‚   â”‚   â””â”€â”€ service_locator.dart # DI setup
â”‚   â”‚
â”‚   â”œâ”€â”€ plugins/                # Plugin system
â”‚   â”‚   â”œâ”€â”€ core/               # Plugin infrastructure
â”‚   â”‚   â”‚   â”œâ”€â”€ plugin_manager.dart    # Plugin lifecycle
â”‚   â”‚   â”‚   â”œâ”€â”€ plugin_registry.dart   # Plugin tracking
â”‚   â”‚   â”‚   â””â”€â”€ plugin_discovery.dart  # Auto-discovery
â”‚   â”‚   â”œâ”€â”€ interfaces/         # Plugin contracts
â”‚   â”‚   â”‚   â”œâ”€â”€ base_plugin.dart       # Base interface
â”‚   â”‚   â”‚   â”œâ”€â”€ service_plugin.dart    # Service plugins
â”‚   â”‚   â”‚   â”œâ”€â”€ widget_plugin.dart     # Widget plugins
â”‚   â”‚   â”‚   â”œâ”€â”€ theme_plugin.dart      # Theme plugins
â”‚   â”‚   â”‚   â””â”€â”€ workflow_plugin.dart   # Workflow plugins
â”‚   â”‚   â””â”€â”€ examples/           # Example plugins
â”‚   â”‚       â”œâ”€â”€ analytics_plugin.dart
â”‚   â”‚       â””â”€â”€ chart_widget_plugin.dart
â”‚   â”‚
â”‚   â”œâ”€â”€ services/               # Business logic services
â”‚   â”‚   â”œâ”€â”€ database_service.dart
â”‚   â”‚   â”œâ”€â”€ auth_service.dart
â”‚   â”‚   â”œâ”€â”€ network_service.dart
â”‚   â”‚   â”œâ”€â”€ preferences_service.dart
â”‚   â”‚   â””â”€â”€ navigation_service.dart
â”‚   â”‚
â”‚   â”œâ”€â”€ ui/                     # UI layer components
â”‚   â”‚   â”œâ”€â”€ adaptive/           # Adaptive widget system
â”‚   â”‚   â”‚   â”œâ”€â”€ adaptive_widget_factory.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ material_widget_factory.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ cupertino_widget_factory.dart
â”‚   â”‚   â”‚   â””â”€â”€ forui_widget_factory.dart
â”‚   â”‚   â”œâ”€â”€ screens/            # Common screens
â”‚   â”‚   â”‚   â”œâ”€â”€ settings_screen.dart
â”‚   â”‚   â”‚   â””â”€â”€ service_inspector_screen.dart
â”‚   â”‚   â””â”€â”€ themes/             # Theme definitions
â”‚   â”‚
â”‚   â”œâ”€â”€ state/                  # State management
â”‚   â”‚   â”œâ”€â”€ app_shell_settings_store.dart
â”‚   â”‚   â””â”€â”€ signals_extensions.dart
â”‚   â”‚
â”‚   â”œâ”€â”€ models/                 # Data models
â”‚   â”‚   â”œâ”€â”€ user.dart
â”‚   â”‚   â”œâ”€â”€ document.dart
â”‚   â”‚   â””â”€â”€ app_config_models.dart
â”‚   â”‚
â”‚   â””â”€â”€ utils/                  # Utilities
â”‚       â”œâ”€â”€ logging.dart
â”‚       â”œâ”€â”€ validators.dart
â”‚       â””â”€â”€ constants.dart
â”‚
â””â”€â”€ flutter_app_shell.dart     # Main export file
```

## ğŸ”„ Data Flow

### 1. User Interaction Flow
```
User Action â†’ Widget â†’ Service â†’ State Update â†’ UI Rebuild
     â†“           â†“        â†“           â†“            â†“
  Tap Button â†’ onPressed â†’ updateData â†’ signal.value = newData â†’ Watch rebuilds
```

### 2. Service Communication Flow
```
Service A â†’ Signal Update â†’ Effect/Watch â†’ Service B Action
    â†“           â†“              â†“             â†“
AuthService â†’ user.value = newUser â†’ effect(() => {}) â†’ DatabaseService.sync()
```

### 3. Cloud Sync Flow
```
Local Change â†’ Service â†’ Local Storage â†’ Background Sync â†’ Cloud Storage
      â†“          â†“           â†“               â†“              â†“
  User Edit â†’ DatabaseService â†’ InstantDB â†’ Real-time Sync â†’ Cloud DB
                                 â†“
Cloud Change â†’ WebSocket â†’ Service Update â†’ Signal â†’ UI Update
```

## ğŸ¯ Key Design Patterns

### 1. Factory Pattern (Adaptive UI)
```dart
// Abstract factory
abstract class AdaptiveWidgetFactory {
  Widget createButton();
  Widget createTextField();
}

// Concrete factories
class MaterialWidgetFactory implements AdaptiveWidgetFactory { /* ... */ }
class CupertinoWidgetFactory implements AdaptiveWidgetFactory { /* ... */ }

// Factory selection
AdaptiveWidgetFactory getFactory(String uiSystem) {
  switch (uiSystem) {
    case 'material': return MaterialWidgetFactory();
    case 'cupertino': return CupertinoWidgetFactory();
    default: return MaterialWidgetFactory();
  }
}
```

### 2. Singleton Pattern (Services)
```dart
class DatabaseService {
  static DatabaseService? _instance;
  static DatabaseService get instance => _instance ??= DatabaseService._();
  DatabaseService._(); // Private constructor

  // Service implementation...
}
```

### 3. Observer Pattern (Reactive State)
```dart
// Signal is the subject
final signal = Signal<String>('initial');

// Watch widgets are observers
Watch((context) => Text(signal.value)) // Rebuilds when signal changes

// Effects are also observers
effect(() => print('Signal changed: ${signal.value}'));
```

### 4. Repository Pattern (Data Access)
```dart
abstract class UserRepository {
  Future<User?> getUser(String id);
  Future<void> saveUser(User user);
  Stream<List<User>> watchUsers();
}

class LocalUserRepository implements UserRepository {
  final DatabaseService _db;
  // Implementation using local database
}

class CloudUserRepository implements UserRepository {
  final InstantDBService _instantdb;
  // Implementation using cloud service
}
```

## ğŸ§ª Testing Architecture

### Service Testing
```dart
void main() {
  late DatabaseService databaseService;
  
  setUp(() {
    // Use in-memory database for testing
    databaseService = DatabaseService.forTesting();
  });
  
  test('should save and retrieve user', () async {
    final user = User(id: '1', name: 'Test User');
    await databaseService.saveUser(user);
    
    final retrieved = await databaseService.getUser('1');
    expect(retrieved, equals(user));
  });
}
```

### Widget Testing with Adaptive UI
```dart
void main() {
  testWidgets('should render material button in material mode', (tester) async {
    await tester.pumpWidget(
      TestApp(
        uiSystem: 'material',
        child: MyWidget(),
      ),
    );
    
    expect(find.byType(MaterialButton), findsOneWidget);
    expect(find.byType(CupertinoButton), findsNothing);
  });
}
```

## ğŸ”§ Configuration & Initialization

### App Initialization Flow
```dart
void main() {
  runShellApp(() async {
    // 1. Setup logging
    setupLogging();
    
    // 2. Initialize core services
    await initializeCoreServices();
    
    // 3. Register custom services
    registerCustomServices();
    
    // 4. Load user preferences
    await loadUserPreferences();
    
    // 5. Return app configuration
    return AppConfig(
      title: 'My App',
      routes: getAppRoutes(),
      theme: getAppTheme(),
    );
  });
}
```

### Service Initialization Order
1. **Logging Service** - For debugging all other initialization
2. **Preferences Service** - To load saved settings
3. **Settings Store** - To restore user preferences
4. **Navigation Service** - For routing setup
5. **Database Service** - For local data storage
6. **Network Service** - For API communication
7. **Authentication Service** - For user management
8. **Custom Services** - Your app-specific services

## ğŸ“Š Performance Considerations

### Lazy Loading
Services are only initialized when first accessed:
```dart
// Service registration (fast)
getIt.registerLazySingleton<ExpensiveService>(() => ExpensiveService());

// Service initialization (only when needed)
final service = getIt<ExpensiveService>(); // Created on first access
```

### Granular Reactivity
Signals provide fine-grained reactivity:
```dart
// Only widgets watching specific signals rebuild
final name = signal('John');
final age = signal(25);

// This only rebuilds when name changes
Watch((context) => Text(name.value))

// This only rebuilds when age changes  
Watch((context) => Text('Age: ${age.value}'))
```

### Efficient UI Updates
The adaptive system minimizes rebuilds:
```dart
// UI system change only rebuilds affected components
settingsStore.uiSystem.value = 'cupertino';
// Only Watch widgets using adaptive factories rebuild
```

## ğŸ”„ Extension Points

### Plugin System
The framework provides a comprehensive plugin system for extensions:

```dart
// Service Plugin Example
class AnalyticsPlugin extends BaseServicePlugin {
  @override
  String get id => 'com.example.analytics';
  
  @override
  Future<void> registerServices(GetIt getIt) async {
    getIt.registerSingleton<AnalyticsService>(AnalyticsService());
  }
}

// Widget Plugin Example
class ChartPlugin extends BaseWidgetExtensionPlugin {
  @override
  Map<String, AdaptiveWidgetBuilder> get widgets => {
    'line_chart': _buildLineChart,
    'bar_chart': _buildBarChart,
  };
}

// Register plugins
runShellApp(
  () async => AppConfig(...),
  enablePlugins: true,
  pluginConfiguration: {
    'manualPlugins': [AnalyticsPlugin(), ChartPlugin()],
  },
);
```

### Plugin Types
1. **Service Plugins** - Business logic and data access
2. **Widget Plugins** - Custom UI components
3. **Theme Plugins** - Complete UI systems
4. **Workflow Plugins** - Automation and processing

### Adding Custom Services (Without Plugins)
```dart
// 1. Create your service
class AnalyticsService {
  static AnalyticsService? _instance;
  static AnalyticsService get instance => _instance ??= AnalyticsService._();
  AnalyticsService._();
  
  void track(String event) { /* implementation */ }
}

// 2. Register in service locator
getIt.registerSingleton<AnalyticsService>(AnalyticsService.instance);

// 3. Use anywhere
getIt<AnalyticsService>().track('user_action');
```

### Adding Custom UI Systems
```dart
// 1. Create widget factory
class MyCustomWidgetFactory extends AdaptiveWidgetFactory {
  @override
  Widget button({required String label, required VoidCallback onPressed}) {
    return MyCustomButton(label: label, onPressed: onPressed);
  }
  // ... implement other widgets
}

// 2. Register factory
registerAdaptiveFactory('my_custom', () => MyCustomWidgetFactory());

// 3. Use in settings
settingsStore.uiSystem.value = 'my_custom';
```

## ğŸ“š Next Steps

Now that you understand the architecture, explore these areas:

- **[Plugin System](plugin-system.md)** - Learn about the extensible plugin architecture
- **[Service Documentation](services/README.md)** - Deep dive into all available services
- **[UI Systems Guide](ui-systems/README.md)** - Learn about adaptive UI implementation
- **[State Management](state-management.md)** - Master reactive state with Signals
- **[Cloud Integration](cloud/instantdb.md)** - Add cloud features with InstantDB
- **[Custom Services](advanced/custom-services.md)** - Build your own services

The architecture is designed to grow with your app while maintaining clean separation of concerns and excellent developer experience. Happy building! ğŸš€

---

## Adaptive UI Systems

*Complete guide to Material, Cupertino, and ForUI with implementation details*

# Adaptive UI Systems Guide

Flutter App Shell's adaptive UI system is one of its most powerful features, allowing your entire app to switch between different design systems at runtime while maintaining consistent functionality and behavior.

## ğŸ¨ Supported UI Systems

### Material Design 3
Google's latest design system featuring:
- **Vibrant colors** with blue primary palette
- **Heavy elevation** (24px shadows) for depth
- **Rounded corners** (16px radius) for modern feel
- **Material You** theming capabilities
- **Ripple effects** and animations

### Cupertino (iOS)
Apple's native iOS design language:
- **Native iOS controls** and styling
- **System gray backgrounds** and colors
- **Modal presentations** for pickers and dialogs
- **iOS-style navigation** patterns
- **Grouped list sections** for settings

### ForUI (Minimal Modern)
A clean, modern design system:
- **Flat design** with no shadows or elevation
- **Sharp corners** (4px radius) for crisp appearance
- **Zinc color palette** (grays and light colors)
- **High contrast** for accessibility
- **Minimalist aesthetic**

## ğŸ”„ How It Works

### Runtime Switching
The entire app can switch between UI systems instantly:

```dart
final settingsStore = getIt<AppShellSettingsStore>();

// Switch to Cupertino UI
settingsStore.uiSystem.value = 'cupertino';

// Switch to Material UI  
settingsStore.uiSystem.value = 'material';

// Switch to ForUI
settingsStore.uiSystem.value = 'forui';
```

### Automatic Persistence
UI system preference is automatically saved and restored:
- Settings persist across app restarts
- User's choice is remembered
- No manual save/load required

## ğŸ­ Factory Pattern Implementation

### Abstract Factory
All UI components are created through an abstract factory:

```dart
abstract class AdaptiveWidgetFactory {
  // Core UI components
  Widget button({required String label, required VoidCallback onPressed});
  Widget textField({
    String? labelText, 
    ValueChanged<String>? onChanged,
    Widget? prefixIcon,
    Widget? suffixIcon,
    EdgeInsets? prefixIconPadding,
    EdgeInsets? suffixIconPadding,
  });
  Widget scaffold({required Widget body, Widget? appBar});
  
  // Extended components  
  Future<DateTime?> showDatePicker({required BuildContext context, ...});
  Future<TimeOfDay?> showTimePicker({required BuildContext context, ...});
  Widget rangeSlider({required RangeValues values, ...});
  
  // Navigation helpers
  Widget navigationRail({required List<AppRoute> routes, ...});
  bool shouldAddDrawerButton();
  bool needsDesktopPadding();
}
```

### Concrete Implementations
Each UI system has its own factory implementation:

```dart
// Material implementation
class MaterialWidgetFactory extends AdaptiveWidgetFactory {
  @override
  Widget button({required String label, required VoidCallback onPressed}) {
    return FilledButton(
      onPressed: onPressed,
      child: Text(label),
    );
  }
  
  @override
  Future<DateTime?> showDatePicker({...}) {
    return material.showDatePicker(
      context: context,
      // Material-specific theming with blue colors and elevation
      builder: (context, child) => Theme(
        data: Theme.of(context).copyWith(
          datePickerTheme: DatePickerThemeData(
            elevation: 24, // Heavy Material elevation
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(16), // Rounded corners
            ),
            // Blue color scheme...
          ),
        ),
        child: child!,
      ),
    );
  }
}

// Cupertino implementation  
class CupertinoWidgetFactory extends AdaptiveWidgetFactory {
  @override
  Widget button({required String label, required VoidCallback onPressed}) {
    return CupertinoButton.filled(
      onPressed: onPressed,
      child: Text(label),
    );
  }
  
  @override
  Future<DateTime?> showDatePicker({...}) {
    // Native iOS modal date picker
    return showCupertinoModalPopup<DateTime>(
      context: context,
      builder: (context) => Container(
        height: 216,
        child: CupertinoDatePicker(
          mode: CupertinoDatePickerMode.date,
          onDateTimeChanged: (date) => selectedDate = date,
        ),
      ),
    );
  }
}

// ForUI implementation
class ForUIWidgetFactory extends AdaptiveWidgetFactory {
  @override
  Widget button({required String label, required VoidCallback onPressed}) {
    return ElevatedButton(
      onPressed: onPressed,
      style: ElevatedButton.styleFrom(
        elevation: 0, // Flat design
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(4), // Sharp corners
        ),
      ),
      child: Text(label),
    );
  }
  
  @override
  Future<DateTime?> showDatePicker({...}) {
    return material.showDatePicker(
      context: context,
      // ForUI-specific theming with flat design and zinc colors
      builder: (context, child) => Theme(
        data: ThemeData.light().copyWith(
          dialogTheme: DialogThemeData(
            elevation: 0, // No shadows
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(4), // Sharp corners
              side: BorderSide(color: Color(0xFFD4D4D8), width: 2), // Border
            ),
          ),
          // Zinc color palette...
        ),
        child: child!,
      ),
    );
  }
}
```

## ğŸ“± Usage in Your App

### Getting the Factory
Always use the adaptive factory in your widgets:

```dart
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final ui = getAdaptiveFactory(context);
    final styles = context.adaptiveStyle;
    
    return ui.scaffold(
      body: Column(
        children: [
          ui.button(
            label: 'Adaptive Button',
            onPressed: () {},
          ),
          ui.textField(
            labelText: 'Adaptive Input',
            onChanged: (value) {},
          ),
        ],
      ),
    );
  }
}
```

### Reactive Updates
Use Watch widgets to automatically rebuild when UI system changes:

```dart
class AdaptiveWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final settingsStore = getIt<AppShellSettingsStore>();
    
    return Watch((context) {
      // Automatically rebuilds when UI system changes
      final uiSystem = settingsStore.uiSystem.value;
      final ui = getAdaptiveFactory(context);
      
      return ui.scaffold(
        key: ValueKey('scaffold_$uiSystem'), // Force rebuild
        body: ui.button(
          label: 'Current UI: $uiSystem',
          onPressed: () {},
        ),
      );
    });
  }
}
```

## ğŸ¨ Visual Differences

### Button Styles
| UI System | Style | Colors | Shape |
|-----------|--------|---------|--------|
| Material | FilledButton | Blue primary | Rounded (16px) |
| Cupertino | CupertinoButton.filled | iOS Blue | Rounded (8px) |
| ForUI | ElevatedButton (flat) | Zinc/Gray | Sharp (4px) |

### Date/Time Pickers
| UI System | Presentation | Colors | Styling |
|-----------|-------------|---------|----------|
| Material | Dialog | Blue theme, heavy elevation (24px) | Rounded corners |
| Cupertino | Modal popup | iOS system colors | Native wheel picker |
| ForUI | Dialog | Zinc palette, flat design (0px elevation) | Sharp borders |

### List Sections  
| UI System | Style | Background | Spacing |
|-----------|--------|------------|----------|
| Material | Card with elevation | White with blue tint | 8px margin |
| Cupertino | Grouped sections | System gray | Inset grouped style |
| ForUI | Bordered container | Light gray | Flat with borders |

## ğŸ”§ Component Library

### Core Components (30+ Widgets)
- **Layout**: scaffold, appBar, drawer, navigationRail
- **Buttons**: button, iconButton, textButton, outlinedButton
- **Inputs**: textField, checkbox, radio, switch, slider
- **Lists**: listTile, listSection, divider
- **Display**: card, avatar, badge, chip
- **Feedback**: progressIndicator, snackBar, dialog
- **Navigation**: tabBar, segmentedControl, stepper

### Extended Components
- **Date/Time**: datePicker, timePicker, dateRangePicker
- **Controls**: rangeSlider, toggleButtons, expansionTile
- **Data**: chip variations (action, choice, filter)
- **Layout**: tooltip, badge with advanced positioning

### Navigation Helpers
- **Responsive**: Automatic navigation adaptation
- **Platform-specific**: Drawer button handling
- **Desktop**: Safe area and padding management

## ğŸ” TextField with Icons

The `textField` component supports prefix and suffix icons with customizable padding:

### Basic Usage

```dart
ui.textField(
  labelText: 'Search',
  hintText: 'Search for something...',
  prefixIcon: const Icon(Icons.search),
  suffixIcon: IconButton(
    icon: const Icon(Icons.clear),
    onPressed: () => controller.clear(),
  ),
)
```

### Advanced Icon Configuration

```dart
ui.textField(
  labelText: 'Email',
  hintText: 'user@example.com',
  prefixIcon: const Icon(Icons.email_outlined),
  suffixIcon: const Icon(Icons.check_circle, color: Colors.green),
  prefixIconPadding: const EdgeInsets.only(left: 12, right: 8),
  suffixIconPadding: const EdgeInsets.only(left: 8, right: 12),
  keyboardType: TextInputType.emailAddress,
)
```

### Platform-Specific Behavior

| UI System | Implementation | Icon Styling | Padding Defaults |
|-----------|----------------|--------------|------------------|
| Material | `InputDecoration.prefixIcon/suffixIcon` | Inherits theme colors | Material design spacing |
| Cupertino | `CupertinoTextField.prefix/suffix` | Wrapped in Padding | iOS-style spacing (8px/4px) |
| ForUI | `InputDecoration` with `IconTheme` | Muted foreground color, 16px size | Minimal spacing (8px/4px) |

### Interactive Icons

```dart
ui.textField(
  labelText: 'Password',
  obscureText: !_passwordVisible,
  prefixIcon: const Icon(Icons.lock_outline),
  suffixIcon: IconButton(
    icon: Icon(_passwordVisible ? Icons.visibility : Icons.visibility_off),
    onPressed: () => setState(() => _passwordVisible = !_passwordVisible),
  ),
)
```

## ğŸ“ Responsive Behavior

### Automatic Layout Adaptation
The navigation system automatically adapts based on screen size:

```dart
// Mobile (<600px)
if (routes.length <= 5) {
  // Bottom navigation tabs
  return BottomNavigationBar(...);
} else {
  // Drawer with hamburger menu
  return Drawer(...);
}

// Tablet (600-1200px)  
return NavigationRail(
  extended: showLabels,
  destinations: [...],
);

// Desktop (>1200px)
return NavigationSidebar(
  collapsed: sidebarCollapsed,
  destinations: [...],
);
```

### Platform-Specific Behavior
Each UI system handles responsive behavior differently:

```dart
// Material - automatic drawer handling
class MaterialWidgetFactory {
  @override
  bool shouldAddDrawerButton() => false; // Scaffold handles it
  
  @override  
  bool needsDesktopPadding() => true; // Manual padding needed
}

// Cupertino - manual drawer button needed
class CupertinoWidgetFactory {
  @override
  bool shouldAddDrawerButton() => true; // Manual button required
  
  @override
  bool needsDesktopPadding() => false; // Handles own padding
}
```

## ğŸ›ï¸ Customization

### Adding New UI Systems
You can extend the framework with custom UI systems:

```dart
// 1. Create your factory
class MyCustomWidgetFactory extends AdaptiveWidgetFactory {
  @override
  Widget button({required String label, required VoidCallback onPressed}) {
    return MyCustomButton(
      label: label,
      onPressed: onPressed,
      style: MyCustomStyle(),
    );
  }
  
  // Implement all required methods...
}

// 2. Register the factory
void registerCustomUISystem() {
  registerAdaptiveFactory('my_custom', () => MyCustomWidgetFactory());
}

// 3. Use in your app
settingsStore.uiSystem.value = 'my_custom';
```

### Theming Individual Systems
Each system can be customized with themes:

```dart
// Material theming
MaterialApp(
  theme: ThemeData.from(
    colorScheme: ColorScheme.fromSeed(seedColor: Colors.purple),
    useMaterial3: true,
  ),
)

// Cupertino theming  
CupertinoApp(
  theme: CupertinoThemeData(
    primaryColor: CupertinoColors.systemPurple,
    brightness: Brightness.light,
  ),
)

// ForUI theming (custom)
ThemeData.light().copyWith(
  colorScheme: ColorScheme.light(
    primary: Color(0xFF6366F1), // Custom purple
    surface: Color(0xFFF8FAFC), // Custom background
  ),
)
```

## ğŸ§ª Testing Adaptive UI

### Testing Different UI Systems
```dart
void main() {
  group('Adaptive Button Tests', () {
    testWidgets('renders Material button in material mode', (tester) async {
      await tester.pumpWidget(
        TestAppWrapper(
          uiSystem: 'material',
          child: MyWidget(),
        ),
      );
      
      expect(find.byType(FilledButton), findsOneWidget);
    });
    
    testWidgets('renders Cupertino button in cupertino mode', (tester) async {
      await tester.pumpWidget(
        TestAppWrapper(
          uiSystem: 'cupertino', 
          child: MyWidget(),
        ),
      );
      
      expect(find.byType(CupertinoButton), findsOneWidget);
    });
  });
}
```

### Testing Responsive Behavior
```dart
testWidgets('shows bottom nav on mobile', (tester) async {
  tester.binding.window.physicalSizeTestValue = Size(400, 800); // Mobile size
  
  await tester.pumpWidget(MyApp());
  
  expect(find.byType(BottomNavigationBar), findsOneWidget);
  expect(find.byType(NavigationRail), findsNothing);
});

testWidgets('shows navigation rail on tablet', (tester) async {
  tester.binding.window.physicalSizeTestValue = Size(800, 600); // Tablet size
  
  await tester.pumpWidget(MyApp());
  
  expect(find.byType(NavigationRail), findsOneWidget);
  expect(find.byType(BottomNavigationBar), findsNothing);
});
```

## ğŸ’¡ Best Practices

### 1. Always Use Adaptive Factory
```dart
// âœ… Good - Adaptive
final ui = getAdaptiveFactory(context);
ui.button(label: 'Click me', onPressed: () {});

// âŒ Bad - Platform-specific  
FilledButton(onPressed: () {}, child: Text('Click me'));
```

### 2. Use Watch for Reactive Updates
```dart
// âœ… Good - Reactive to UI system changes
Watch((context) {
  final ui = getAdaptiveFactory(context);
  return ui.button(label: 'Adaptive', onPressed: () {});
})

// âŒ Bad - Won't update when UI system changes
Widget build(BuildContext context) {
  final ui = getAdaptiveFactory(context);
  return ui.button(label: 'Static', onPressed: () {});
}
```

### 3. Provide Unique Keys for System Changes
```dart
// âœ… Good - Forces rebuild on UI system change
return Watch((context) {
  final uiSystem = settingsStore.uiSystem.value;
  return ui.scaffold(
    key: ValueKey('scaffold_$uiSystem'),
    body: myContent,
  );
});
```

### 4. Handle Platform Differences Gracefully
```dart
// Some UI systems may not have certain components
if (ui is CupertinoWidgetFactory) {
  // Cupertino doesn't have native range slider
  // Factory will provide Material fallback
}

final dateTime = await ui.showDatePicker(...);
// Handle the case where user cancels (returns null)
if (dateTime != null) {
  // Use the selected date
}
```

## ğŸ”— Related Guides

- **[Getting Started](../getting-started.md)** - Basic setup with adaptive UI
- **[Material Design](material.md)** - Deep dive into Material implementation  
- **[Cupertino](cupertino.md)** - iOS-specific features and behavior
- **[ForUI](forui.md)** - Modern minimal design system
- **[Component Reference](components.md)** - Complete component documentation
- **[Architecture](../architecture.md)** - How adaptive UI fits in the overall architecture

The adaptive UI system is designed to give you maximum flexibility while maintaining consistency and a great user experience across all platforms. Start with the basics and gradually explore the advanced customization options! ğŸ¨

---

## Services Documentation

*Overview of all 30+ services with architecture patterns and integration guide*

# Services Documentation

Flutter App Shell provides a comprehensive suite of services that handle common app functionality out-of-the-box. All services use dependency injection, reactive state management, and are fully testable. Additional services can be added through the plugin system.

## ğŸ”§ Core Architecture

### Service Locator Pattern
All services are registered and accessed through GetIt:

```dart
// Registration (automatic in runShellApp)
getIt.registerSingleton<DatabaseService>(DatabaseService.instance);
getIt.registerSingleton<AuthenticationService>(AuthenticationService.instance);

// Access anywhere in your app
final db = getIt<DatabaseService>();
final auth = getIt<AuthenticationService>();
```

### Reactive State
Services use Signals for reactive state management:

```dart
// Service exposes reactive state
class AuthenticationService {
  final _isAuthenticated = signal(false);
  Signal<bool> get isAuthenticated => _isAuthenticated;
  
  final _currentUser = signal<User?>(null);
  Signal<User?> get currentUser => _currentUser;
}

// UI reacts automatically  
Watch((context) => Text(
  auth.isAuthenticated.value ? 'Logged In' : 'Logged Out'
))
```

### Service Health Monitoring
All services provide health status for debugging:

```dart
abstract class BaseService {
  ServiceHealth get health;
  String get statusMessage;
  Map<String, dynamic> get debugInfo;
}

enum ServiceHealth { healthy, initializing, error, disabled }
```

## ğŸ“¦ Available Services

### Core Services
| Service | Description | Key Features |
|---------|-------------|--------------|
| [NavigationService](navigation.md) | Centralized navigation | GoRouter integration, deep linking |
| [PreferencesService](preferences.md) | Settings storage | Type-safe, reactive, automatic persistence |
| [LoggingService](logging.md) | Structured logging | Multiple levels, file output, filtering |

### Data Services  
| Service | Description | Key Features |
|---------|-------------|--------------|
| [DatabaseService](database.md) | Real-time NoSQL storage | InstantDB-based, reactive queries, real-time sync, zero code generation |
| [NetworkService](networking.md) | HTTP client | Dio-based, offline queue, retry logic |
| [FileStorageService](file-storage.md) | File management | Local + cloud storage, progress tracking |

### User Services
| Service | Description | Key Features |
|---------|-------------|--------------|
| [AuthenticationService](authentication.md) | User authentication | JWT tokens, biometrics, session management |
| [UserProfileService](user-profile.md) | User profiles | Avatar upload, preferences, social features |
| [NotificationService](notifications.md) | Push notifications | Local + remote, scheduling, badges |

### Cloud Services
| Service | Description | Key Features |
|---------|-------------|--------------|
| DatabaseService | InstantDB integration | Real-time, auth, storage, database |
| [AnalyticsService](analytics.md) | Usage analytics | Event tracking, user journeys, crash reporting |
| [CrashReportingService](crash-reporting.md) | Error monitoring | Automatic reporting, stack traces, user context |

### Device Services
| Service | Description | Key Features |
|---------|-------------|--------------|
| [DeviceInfoService](device-info.md) | Device information | Platform details, capabilities, permissions |
| [ConnectivityService](connectivity.md) | Network monitoring | Online/offline status, connection type |
| [LocationService](location.md) | GPS/location | Background tracking, geofencing, maps |
| [CameraService](camera.md) | Camera/photos | Capture, gallery, image processing |

### Debug Services
| Service | Description | Key Features |
|---------|-------------|--------------|
| [ServiceInspector](inspector.md) | Service debugging | Real-time monitoring, health status, testing |
| [PerformanceService](performance.md) | Performance monitoring | FPS tracking, memory usage, profiling |

## ğŸš€ Getting Started with Services

### Basic Service Usage
```dart
class MyScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Get services from service locator
    final db = getIt<DatabaseService>();
    final auth = getIt<AuthenticationService>();
    final ui = getAdaptiveFactory(context);
    
    return Watch((context) {
      // React to authentication state
      final isLoggedIn = auth.isAuthenticated.value;
      
      if (!isLoggedIn) {
        return LoginScreen();
      }
      
      return ui.scaffold(
        body: FutureBuilder(
          future: db.findByType('todos'),
          builder: (context, snapshot) {
            if (snapshot.hasData) {
              return TodoList(todos: snapshot.data!);
            }
            return CircularProgressIndicator();
          },
        ),
      );
    });
  }
}
```

### Service Initialization
Services are automatically initialized in the correct order:

```dart
void main() {
  runShellApp(() async {
    // Services are initialized automatically:
    // 1. Logging Service (for debugging initialization)
    // 2. Preferences Service (for loading settings) 
    // 3. Settings Store (for user preferences)
    // 4. Navigation Service (for routing)
    // 5. Database Service (for local storage)
    // 6. Network Service (for API calls)
    // 7. Authentication Service (for user management)
    // 8. Your custom services
    
    return AppConfig(
      title: 'My App',
      routes: [...],
    );
  });
}
```

## ğŸ”— Service Integration Patterns

### Cross-Service Communication
Services communicate through reactive signals:

```dart
class AuthenticationService {
  final _currentUser = signal<User?>(null);
  
  Future<void> login(String email, String password) async {
    final user = await _performLogin(email, password);
    _currentUser.value = user;
    
    // Other services can react to this change
  }
}

class DatabaseService {
  AuthenticationService? _auth;
  
  void initialize() {
    _auth = getIt<AuthenticationService>();
    
    // React to authentication changes
    effect(() {
      final user = _auth!.currentUser.value;
      if (user != null) {
        _switchToUserDatabase(user.id);
      } else {
        _clearDatabase();
      }
    });
  }
}
```

### Service Composition
Build complex functionality by combining services:

```dart
class UserDataManager {
  final DatabaseService _db = getIt<DatabaseService>();
  final FileStorageService _storage = getIt<FileStorageService>();
  final AuthenticationService _auth = getIt<AuthenticationService>();
  
  Future<UserProfile> loadUserProfile() async {
    final userId = _auth.currentUser.value?.id;
    if (userId == null) throw Exception('Not authenticated');
    
    // Load profile data from database
    final profileDoc = await _db.findById('user_profiles', userId);
    
    // Load profile image from storage
    final imageUrl = await _storage.getPublicUrl(
      fileName: 'profile_$userId.jpg',
      folder: 'avatars',
    );
    
    return UserProfile(
      data: profileDoc?.data,
      imageUrl: imageUrl,
    );
  }
}
```

## ğŸ§ª Testing Services

### Unit Testing
```dart
void main() {
  late DatabaseService databaseService;
  
  setUp(() {
    // Use test implementation
    databaseService = DatabaseService.forTesting();
  });
  
  test('should save and retrieve documents', () async {
    // Test service functionality
    final doc = {'title': 'Test Document', 'content': 'Test content'};
    final id = await databaseService.create('documents', doc);
    
    final retrieved = await databaseService.findById('documents', id);
    expect(retrieved?.data, equals(doc));
  });
  
  tearDown(() {
    databaseService.dispose();
  });
}
```

### Integration Testing
```dart
void main() {
  group('Authentication Flow', () {
    testWidgets('should login and sync data', (tester) async {
      // Setup test app with services
      await tester.pumpWidget(TestApp());
      
      // Perform login
      await tester.enterText(find.byKey(Key('email')), 'test@example.com');
      await tester.enterText(find.byKey(Key('password')), 'password');
      await tester.tap(find.byKey(Key('login')));
      await tester.pumpAndSettle();
      
      // Verify services responded correctly
      final auth = getIt<AuthenticationService>();
      final db = getIt<DatabaseService>();
      
      expect(auth.isAuthenticated.value, isTrue);
      expect(db.currentUserId, equals('test-user-id'));
    });
  });
}
```

### Mock Services
```dart
class MockDatabaseService extends DatabaseService {
  final Map<String, Map<String, dynamic>> _mockData = {};
  
  @override
  Future<String> create(String type, Map<String, dynamic> data) async {
    final id = 'mock_${DateTime.now().millisecondsSinceEpoch}';
    _mockData[id] = {...data, 'type': type};
    return id;
  }
  
  @override
  Future<Document?> findById(String type, String id) async {
    final data = _mockData[id];
    if (data == null || data['type'] != type) return null;
    
    return Document(id: id, type: type, data: data);
  }
}

// Use in tests
setUp(() {
  getIt.registerSingleton<DatabaseService>(MockDatabaseService());
});
```

## ğŸ”§ Configuration

### Service Configuration
Many services can be configured during initialization:

```dart
void main() {
  runShellApp(() async {
    // Configure logging
    await LoggingService.initialize(
      level: LogLevel.debug,
      writeToFile: true,
      maxFileSize: 10 * 1024 * 1024, // 10MB
    );
    
    // Configure database
    await DatabaseService.initialize(
      enableCloudSync: true,
      syncInterval: Duration(minutes: 5),
      conflictResolution: ConflictResolutionStrategy.lastWriteWins,
    );
    
    // Configure networking
    await NetworkService.initialize(
      baseUrl: 'https://api.myapp.com',
      timeout: Duration(seconds: 30),
      retryPolicy: RetryPolicy.exponentialBackoff(),
    );
    
    return AppConfig(...);
  });
}
```

### Environment-Based Configuration
```dart
// Use different configurations for different environments
final config = Environment.isDevelopment 
    ? DevelopmentConfig()
    : ProductionConfig();

await DatabaseService.initialize(config.databaseConfig);
await NetworkService.initialize(config.networkConfig);
```

## ğŸ“Š Service Inspector

The Service Inspector provides real-time monitoring and debugging:

```dart
// Access via settings screen or add as route
AppRoute(
  title: 'Inspector',
  path: '/inspector',
  icon: Icons.bug_report,
  builder: (context, state) => const ServiceInspectorScreen(),
),
```

**Features:**
- **Health Status** - Green/yellow/red indicators for each service
- **Live Metrics** - Real-time performance and usage statistics  
- **Interactive Testing** - Test service operations with one click
- **Debug Information** - Detailed service state and configuration
- **Error Reporting** - Recent errors and stack traces

## ğŸ” Debugging Services

### Logging Integration
All services integrate with the logging system:

```dart
class MyService {
  static final _logger = Logger('MyService');
  
  Future<void> performOperation() async {
    _logger.info('Starting operation');
    
    try {
      await _doSomething();
      _logger.debug('Operation completed successfully');
    } catch (e, stackTrace) {
      _logger.error('Operation failed', e, stackTrace);
      rethrow;
    }
  }
}
```

### Health Monitoring
Monitor service health in real-time:

```dart
class DatabaseService extends BaseService {
  @override
  ServiceHealth get health {
    if (!_isInitialized) return ServiceHealth.initializing;
    if (_hasErrors) return ServiceHealth.error;
    return ServiceHealth.healthy;
  }
  
  @override
  String get statusMessage {
    switch (health) {
      case ServiceHealth.healthy:
        return 'Connected and operational';
      case ServiceHealth.initializing:
        return 'Initializing database connection';
      case ServiceHealth.error:
        return 'Database connection failed: $_lastError';
      default:
        return 'Unknown status';
    }
  }
  
  @override
  Map<String, dynamic> get debugInfo => {
    'documents_count': _documentCount,
    'last_sync': _lastSyncTime?.toIso8601String(),
    'cache_size': _cacheSize,
    'pending_operations': _pendingOperations.length,
  };
}
```

## ğŸ”Œ Plugin-Provided Services

Flutter App Shell supports extending services through the plugin system:

### Using Service Plugins
```dart
// Install and use analytics plugin
final analyticsPlugin = AnalyticsPlugin();

runShellApp(
  () async => AppConfig(...),
  enablePlugins: true,
  pluginConfiguration: {
    'manualPlugins': [analyticsPlugin],
  },
);

// Access plugin services via GetIt
final analytics = getIt<AnalyticsService>();
await analytics.trackEvent('user_action');
```

### Common Plugin Services
- **Analytics Services** - Track user behavior and app usage
- **Payment Services** - Process payments and subscriptions
- **Communication Services** - Chat, video calls, notifications
- **Integration Services** - CRM, ERP, third-party APIs
- **AI/ML Services** - Machine learning models and predictions

### Creating Service Plugins
```dart
class MyServicePlugin extends BaseServicePlugin {
  @override
  String get id => 'com.mycompany.myservice';
  
  @override
  List<Type> get serviceTypes => [MyService];
  
  @override
  Future<void> registerServices(GetIt getIt) async {
    getIt.registerSingleton<MyService>(MyService());
  }
}
```

Learn more in the [Plugin System documentation](../plugin-system.md).

## ğŸ”— Service-Specific Guides

### Essential Services
- **[Database Service](database.md)** - Local storage with cloud sync
- **[Authentication Service](authentication.md)** - User authentication and management  
- **[Network Service](networking.md)** - HTTP client with offline support
- **[Navigation Service](navigation.md)** - Centralized navigation management

### Advanced Services
- **[File Storage Service](file-storage.md)** - Local and cloud file management
- **[Database Service](database.md)** - Complete InstantDB integration
- **[Service Inspector](inspector.md)** - Real-time debugging and monitoring

### Extending Services
- **[Custom Services](../advanced/custom-services.md)** - Create your own services
- **[Plugin System](../plugin-system.md)** - Extend with service plugins
- **[Service Testing](../advanced/testing.md)** - Advanced testing strategies

The service architecture is designed to be modular, testable, and easy to extend. Start with the core services and gradually add more advanced functionality as your app grows! ğŸš€

---

## Common Patterns & Examples

*Real-world code examples for authentication, data management, UI patterns, and performance*

# Common Patterns & Examples

This guide provides practical examples and recommended patterns for building applications with Flutter App Shell. Use these patterns as starting points for your own implementations.

## ğŸ” Authentication Patterns

### Basic Login/Logout Flow
```dart
class AuthScreen extends StatefulWidget {
  @override
  _AuthScreenState createState() => _AuthScreenState();
}

class _AuthScreenState extends State<AuthScreen> {
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _formKey = GlobalKey<FormState>();
  
  @override
  Widget build(BuildContext context) {
    final auth = getIt<AuthenticationService>();
    final ui = getAdaptiveFactory(context);
    
    return Watch((context) {
      final isLoading = auth.isLoading.value;
      final isAuthenticated = auth.isAuthenticated.value;
      
      // Redirect if already authenticated
      if (isAuthenticated) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          getIt<NavigationService>().goToPath('/dashboard');
        });
      }
      
      return ui.scaffold(
        body: Padding(
          padding: const EdgeInsets.all(24),
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                ui.textField(
                  controller: _emailController,
                  labelText: 'Email',
                  keyboardType: TextInputType.emailAddress,
                  validator: (value) {
                    if (value?.isEmpty ?? true) return 'Email required';
                    if (!value!.contains('@')) return 'Invalid email';
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                ui.textField(
                  controller: _passwordController,
                  labelText: 'Password',
                  obscureText: true,
                  validator: (value) {
                    if (value?.isEmpty ?? true) return 'Password required';
                    if (value!.length < 6) return 'Password too short';
                    return null;
                  },
                ),
                const SizedBox(height: 32),
                SizedBox(
                  width: double.infinity,
                  child: ui.button(
                    label: isLoading ? 'Signing In...' : 'Sign In',
                    onPressed: isLoading ? null : _handleLogin,
                  ),
                ),
              ],
            ),
          ),
        ),
      );
    });
  }
  
  Future<void> _handleLogin() async {
    if (!_formKey.currentState!.validate()) return;
    
    final auth = getIt<AuthenticationService>();
    final ui = getAdaptiveFactory(context);
    
    try {
      await auth.signInWithEmailAndPassword(
        _emailController.text.trim(),
        _passwordController.text,
      );
    } catch (e) {
      ui.showSnackBar(
        context: context,
        content: Text('Login failed: ${e.toString()}'),
      );
    }
  }
}
```

### Protected Route Pattern
```dart
class ProtectedRoute extends StatelessWidget {
  final Widget child;
  final String redirectPath;
  
  const ProtectedRoute({
    Key? key,
    required this.child,
    this.redirectPath = '/auth',
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    final auth = getIt<AuthenticationService>();
    
    return Watch((context) {
      final isAuthenticated = auth.isAuthenticated.value;
      
      if (!isAuthenticated) {
        // Redirect to login
        WidgetsBinding.instance.addPostFrameCallback((_) {
          getIt<NavigationService>().goToPath(redirectPath);
        });
        return const Scaffold(
          body: Center(child: CircularProgressIndicator()),
        );
      }
      
      return child;
    });
  }
}

// Usage in routes
AppRoute(
  title: 'Dashboard',
  path: '/dashboard',
  icon: Icons.dashboard,
  builder: (context, state) => ProtectedRoute(
    child: DashboardScreen(),
  ),
),
```

## ğŸ“Š Data Management Patterns

### CRUD List Pattern
```dart
class TodoListScreen extends StatefulWidget {
  @override
  _TodoListScreenState createState() => _TodoListScreenState();
}

class _TodoListScreenState extends State<TodoListScreen> {
  final _titleController = TextEditingController();
  
  @override
  Widget build(BuildContext context) {
    final db = getIt<DatabaseService>();
    final ui = getAdaptiveFactory(context);
    
    return ui.scaffold(
      appBar: ui.appBar(
        title: const Text('Todos'),
        actions: [
          ui.iconButton(
            icon: const Icon(Icons.add),
            onPressed: _showAddDialog,
          ),
        ],
      ),
      body: StreamBuilder<List<Document>>(
        stream: db.watchByType('todos'),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          
          if (snapshot.hasError) {
            return Center(
              child: Text('Error: ${snapshot.error}'),
            );
          }
          
          final todos = snapshot.data ?? [];
          
          if (todos.isEmpty) {
            return const Center(
              child: Text('No todos yet. Add one to get started!'),
            );
          }
          
          return ListView.builder(
            itemCount: todos.length,
            itemBuilder: (context, index) {
              final todo = todos[index];
              return _TodoTile(
                todo: todo,
                onToggle: () => _toggleTodo(todo),
                onDelete: () => _deleteTodo(todo),
                onEdit: () => _editTodo(todo),
              );
            },
          );
        },
      ),
    );
  }
  
  Future<void> _toggleTodo(Document todo) async {
    final db = getIt<DatabaseService>();
    await db.update('todos', todo.id, {
      'completed': !(todo.data['completed'] ?? false),
    });
  }
  
  Future<void> _deleteTodo(Document todo) async {
    final db = getIt<DatabaseService>();
    final ui = getAdaptiveFactory(context);
    
    final confirmed = await ui.showDialog<bool>(
      context: context,
      title: const Text('Delete Todo'),
      content: const Text('Are you sure you want to delete this todo?'),
      actions: [
        ui.textButton(
          label: 'Cancel',
          onPressed: () => Navigator.of(context).pop(false),
        ),
        ui.button(
          label: 'Delete',
          onPressed: () => Navigator.of(context).pop(true),
        ),
      ],
    );
    
    if (confirmed == true) {
      await db.delete('todos', todo.id);
    }
  }
  
  void _showAddDialog() {
    final ui = getAdaptiveFactory(context);
    
    ui.showDialog(
      context: context,
      title: const Text('Add Todo'),
      content: ui.textField(
        controller: _titleController,
        labelText: 'Title',
        autofocus: true,
      ),
      actions: [
        ui.textButton(
          label: 'Cancel',
          onPressed: () => Navigator.of(context).pop(),
        ),
        ui.button(
          label: 'Add',
          onPressed: () => _addTodo(),
        ),
      ],
    );
  }
  
  Future<void> _addTodo() async {
    if (_titleController.text.trim().isEmpty) return;
    
    final db = getIt<DatabaseService>();
    await db.create('todos', {
      'title': _titleController.text.trim(),
      'completed': false,
      'createdAt': DateTime.now().toIso8601String(),
    });
    
    _titleController.clear();
    Navigator.of(context).pop();
  }
}

class _TodoTile extends StatelessWidget {
  final Document todo;
  final VoidCallback onToggle;
  final VoidCallback onDelete;
  final VoidCallback onEdit;
  
  const _TodoTile({
    required this.todo,
    required this.onToggle,
    required this.onDelete,
    required this.onEdit,
  });
  
  @override
  Widget build(BuildContext context) {
    final ui = getAdaptiveFactory(context);
    final isCompleted = todo.data['completed'] ?? false;
    
    return ui.listTile(
      title: Text(
        todo.data['title'] ?? '',
        style: TextStyle(
          decoration: isCompleted ? TextDecoration.lineThrough : null,
        ),
      ),
      leading: ui.checkbox(
        value: isCompleted,
        onChanged: (_) => onToggle(),
      ),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          ui.iconButton(
            icon: const Icon(Icons.edit),
            onPressed: onEdit,
          ),
          ui.iconButton(
            icon: const Icon(Icons.delete),
            onPressed: onDelete,
          ),
        ],
      ),
    );
  }
}
```

### Offline-First Data Pattern
```dart
class OfflineFirstService {
  final DatabaseService _db = getIt<DatabaseService>();
  final NetworkService _network = getIt<NetworkService>();
  
  // Always try local first, then sync if needed
  Future<List<Article>> getArticles({bool forceRefresh = false}) async {
    // 1. Get local data immediately
    final localArticles = await _db.findByType('articles');
    
    // 2. If we have local data and don't need fresh data, return it
    if (localArticles.isNotEmpty && !forceRefresh) {
      // Trigger background sync
      _syncArticlesInBackground();
      return localArticles.map((doc) => Article.fromDocument(doc)).toList();
    }
    
    // 3. Try to fetch from network
    try {
      final response = await _network.get('/articles');
      final articles = (response.data as List)
          .map((json) => Article.fromJson(json))
          .toList();
      
      // 4. Save to local database
      await _saveArticlesToLocal(articles);
      
      return articles;
    } catch (e) {
      // 5. Network failed, return local data as fallback
      return localArticles.map((doc) => Article.fromDocument(doc)).toList();
    }
  }
  
  Future<void> _syncArticlesInBackground() async {
    try {
      final response = await _network.get('/articles');
      final articles = (response.data as List)
          .map((json) => Article.fromJson(json))
          .toList();
      
      await _saveArticlesToLocal(articles);
    } catch (e) {
      // Sync failed, but that's ok for background sync
      print('Background sync failed: $e');
    }
  }
  
  Future<void> _saveArticlesToLocal(List<Article> articles) async {
    for (final article in articles) {
      await _db.create('articles', article.toJson());
    }
  }
}
```

## ğŸ¨ UI Patterns

### Adaptive Form Pattern
```dart
class AdaptiveForm extends StatefulWidget {
  @override
  _AdaptiveFormState createState() => _AdaptiveFormState();
}

class _AdaptiveFormState extends State<AdaptiveForm> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _emailController = TextEditingController();
  final _phoneController = TextEditingController();
  
  @override
  Widget build(BuildContext context) {
    final ui = getAdaptiveFactory(context);
    final styles = context.adaptiveStyle;
    
    return ui.scaffold(
      appBar: ui.appBar(
        title: const Text('Profile Form'),
        actions: [
          ui.textButton(
            label: 'Save',
            onPressed: _saveForm,
          ),
        ],
      ),
      body: ui.form(
        formKey: _formKey,
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            ui.listSection(
              header: const Text('Personal Information'),
              children: [
                ui.textField(
                  controller: _nameController,
                  labelText: 'Full Name',
                  validator: (value) {
                    if (value?.isEmpty ?? true) return 'Name required';
                    return null;
                  },
                ),
                ui.textField(
                  controller: _emailController,
                  labelText: 'Email',
                  keyboardType: TextInputType.emailAddress,
                  validator: (value) {
                    if (value?.isEmpty ?? true) return 'Email required';
                    if (!value!.contains('@')) return 'Invalid email';
                    return null;
                  },
                ),
                ui.textField(
                  controller: _phoneController,
                  labelText: 'Phone Number',
                  keyboardType: TextInputType.phone,
                ),
              ],
            ),
            const SizedBox(height: 24),
            ui.listSection(
              header: const Text('Preferences'),
              children: [
                ui.checkboxListTile(
                  title: const Text('Email Notifications'),
                  value: _emailNotifications,
                  onChanged: (value) {
                    setState(() {
                      _emailNotifications = value ?? false;
                    });
                  },
                ),
                ui.checkboxListTile(
                  title: const Text('Push Notifications'),
                  value: _pushNotifications,
                  onChanged: (value) {
                    setState(() {
                      _pushNotifications = value ?? false;
                    });
                  },
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  
  bool _emailNotifications = true;
  bool _pushNotifications = false;
  
  void _saveForm() {
    if (_formKey.currentState!.validate()) {
      final ui = getAdaptiveFactory(context);
      
      // Save form data
      final formData = {
        'name': _nameController.text,
        'email': _emailController.text,
        'phone': _phoneController.text,
        'emailNotifications': _emailNotifications,
        'pushNotifications': _pushNotifications,
      };
      
      // Show success message
      ui.showSnackBar(
        context: context,
        content: const Text('Profile saved successfully!'),
      );
    }
  }
}
```

### Responsive Layout Pattern
```dart
class ResponsiveDashboard extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final ui = getAdaptiveFactory(context);
    
    return ui.scaffold(
      body: LayoutBuilder(
        builder: (context, constraints) {
          if (constraints.maxWidth < 600) {
            // Mobile layout
            return _MobileLayout();
          } else if (constraints.maxWidth < 1200) {
            // Tablet layout
            return _TabletLayout();
          } else {
            // Desktop layout
            return _DesktopLayout();
          }
        },
      ),
    );
  }
}

class _MobileLayout extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        _HeaderCard(),
        Expanded(
          child: ListView(
            children: [
              _StatsCard(),
              _RecentActivityCard(),
              _QuickActionsCard(),
            ],
          ),
        ),
      ],
    );
  }
}

class _TabletLayout extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        _HeaderCard(),
        Expanded(
          child: Row(
            children: [
              Expanded(
                flex: 2,
                child: Column(
                  children: [
                    _StatsCard(),
                    _RecentActivityCard(),
                  ],
                ),
              ),
              Expanded(
                child: _QuickActionsCard(),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

class _DesktopLayout extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        SizedBox(
          width: 300,
          child: Column(
            children: [
              _HeaderCard(),
              _QuickActionsCard(),
            ],
          ),
        ),
        Expanded(
          child: Column(
            children: [
              _StatsCard(),
              Expanded(child: _RecentActivityCard()),
            ],
          ),
        ),
      ],
    );
  }
}
```

## ğŸ§­ Navigation Patterns

### Tab Navigation with State Preservation
```dart
class MainTabScreen extends StatefulWidget {
  @override
  _MainTabScreenState createState() => _MainTabScreenState();
}

class _MainTabScreenState extends State<MainTabScreen>
    with TickerProviderStateMixin {
  
  late TabController _tabController;
  final List<Widget> _screens = [
    HomeScreen(),
    SearchScreen(),
    ProfileScreen(),
    SettingsScreen(),
  ];
  
  @override
  void initState() {
    super.initState();
    _tabController = TabController(
      length: _screens.length,
      vsync: this,
    );
  }
  
  @override
  Widget build(BuildContext context) {
    final ui = getAdaptiveFactory(context);
    
    return ui.scaffold(
      body: TabBarView(
        controller: _tabController,
        children: _screens.map((screen) => 
          // Preserve state using AutomaticKeepAliveClientMixin
          _KeepAliveWrapper(child: screen)
        ).toList(),
      ),
      bottomNavBar: ui.tabBar(
        controller: _tabController,
        tabs: [
          Tab(icon: Icon(Icons.home), text: 'Home'),
          Tab(icon: Icon(Icons.search), text: 'Search'),
          Tab(icon: Icon(Icons.person), text: 'Profile'),
          Tab(icon: Icon(Icons.settings), text: 'Settings'),
        ],
      ),
    );
  }
}

class _KeepAliveWrapper extends StatefulWidget {
  final Widget child;
  
  const _KeepAliveWrapper({required this.child});
  
  @override
  _KeepAliveWrapperState createState() => _KeepAliveWrapperState();
}

class _KeepAliveWrapperState extends State<_KeepAliveWrapper>
    with AutomaticKeepAliveClientMixin {
  
  @override
  bool get wantKeepAlive => true;
  
  @override
  Widget build(BuildContext context) {
    super.build(context);
    return widget.child;
  }
}
```

### Deep Linking Pattern
```dart
class DeepLinkHandler {
  static void handleDeepLink(String link) {
    final uri = Uri.parse(link);
    final navigation = getIt<NavigationService>();
    
    switch (uri.pathSegments.first) {
      case 'article':
        final articleId = uri.pathSegments.length > 1 
            ? uri.pathSegments[1] 
            : null;
        if (articleId != null) {
          navigation.goToPath('/article/$articleId');
        }
        break;
        
      case 'user':
        final userId = uri.pathSegments.length > 1 
            ? uri.pathSegments[1] 
            : null;
        if (userId != null) {
          navigation.goToPath('/profile/$userId');
        }
        break;
        
      case 'settings':
        final section = uri.queryParameters['section'];
        navigation.goToPath('/settings${section != null ? '?section=$section' : ''}');
        break;
        
      default:
        navigation.goToPath('/');
    }
  }
}

// Usage in main.dart
void main() {
  runShellApp(() async {
    // Handle app launch from deep link
    final initialLink = await getInitialLink();
    if (initialLink != null) {
      DeepLinkHandler.handleDeepLink(initialLink);
    }
    
    // Listen for incoming links while app is running
    getLinksStream().listen((String link) {
      DeepLinkHandler.handleDeepLink(link);
    });
    
    return AppConfig(
      title: 'My App',
      routes: [...],
    );
  });
}
```

## ğŸ”§ Service Integration Patterns

### Service Composition Pattern
```dart
class UserManager {
  final AuthenticationService _auth = getIt<AuthenticationService>();
  final DatabaseService _db = getIt<DatabaseService>();
  final FileStorageService _storage = getIt<FileStorageService>();
  final NetworkService _network = getIt<NetworkService>();
  
  // Signals for reactive state
  final _userProfile = signal<UserProfile?>(null);
  final _isLoading = signal(false);
  
  Signal<UserProfile?> get userProfile => _userProfile;
  Signal<bool> get isLoading => _isLoading;
  
  UserManager() {
    // React to authentication changes
    effect(() {
      final user = _auth.currentUser.value;
      if (user != null) {
        _loadUserProfile(user.id);
      } else {
        _userProfile.value = null;
      }
    });
  }
  
  Future<void> _loadUserProfile(String userId) async {
    _isLoading.value = true;
    
    try {
      // Try local first
      final localProfile = await _db.findById('user_profiles', userId);
      if (localProfile != null) {
        _userProfile.value = UserProfile.fromDocument(localProfile);
      }
      
      // Sync from cloud in background
      _syncProfileFromCloud(userId);
    } catch (e) {
      print('Error loading user profile: $e');
    } finally {
      _isLoading.value = false;
    }
  }
  
  Future<void> _syncProfileFromCloud(String userId) async {
    try {
      final response = await _network.get('/users/$userId/profile');
      final profileData = response.data;
      
      // Save to local database
      await _db.update('user_profiles', userId, profileData);
      
      // Update reactive state
      _userProfile.value = UserProfile.fromJson(profileData);
    } catch (e) {
      // Background sync failed, but local data is still available
      print('Profile sync failed: $e');
    }
  }
  
  Future<void> updateAvatar(File imageFile) async {
    _isLoading.value = true;
    
    try {
      final user = _auth.currentUser.value;
      if (user == null) throw Exception('Not authenticated');
      
      // Upload image to storage
      final result = await _storage.uploadFile(
        file: imageFile,
        folder: 'avatars',
        fileName: 'avatar_${user.id}.jpg',
      );
      
      // Update user profile with new avatar URL
      await _db.update('user_profiles', user.id, {
        'avatarUrl': result.publicUrl,
      });
      
      // Sync to cloud
      await _network.put('/users/${user.id}/profile', {
        'avatarUrl': result.publicUrl,
      });
      
      // Update local state
      final currentProfile = _userProfile.value;
      if (currentProfile != null) {
        _userProfile.value = currentProfile.copyWith(
          avatarUrl: result.publicUrl,
        );
      }
    } catch (e) {
      throw Exception('Failed to update avatar: $e');
    } finally {
      _isLoading.value = false;
    }
  }
}
```

### Event-Driven Service Communication
```dart
class EventBus {
  static final _instance = EventBus._();
  static EventBus get instance => _instance;
  EventBus._();
  
  final _controller = StreamController<AppEvent>.broadcast();
  Stream<AppEvent> get events => _controller.stream;
  
  void emit(AppEvent event) {
    _controller.add(event);
  }
  
  Stream<T> on<T extends AppEvent>() {
    return events.where((event) => event is T).cast<T>();
  }
}

abstract class AppEvent {}

class UserLoggedInEvent extends AppEvent {
  final User user;
  UserLoggedInEvent(this.user);
}

class DocumentCreatedEvent extends AppEvent {
  final Document document;
  DocumentCreatedEvent(this.document);
}

// Services listen for events
class NotificationService {
  void initialize() {
    EventBus.instance.on<UserLoggedInEvent>().listen((event) {
      _sendWelcomeNotification(event.user);
    });
    
    EventBus.instance.on<DocumentCreatedEvent>().listen((event) {
      _notifyDocumentCreated(event.document);
    });
  }
}

// Services emit events
class AuthenticationService {
  Future<void> signIn(String email, String password) async {
    final user = await _performSignIn(email, password);
    _currentUser.value = user;
    
    // Emit event for other services
    EventBus.instance.emit(UserLoggedInEvent(user));
  }
}
```

## ğŸš€ Performance Patterns

### Lazy Loading Pattern
```dart
class LazyListScreen extends StatefulWidget {
  @override
  _LazyListScreenState createState() => _LazyListScreenState();
}

class _LazyListScreenState extends State<LazyListScreen> {
  final List<Article> _articles = [];
  bool _isLoading = false;
  bool _hasMore = true;
  int _page = 0;
  
  @override
  void initState() {
    super.initState();
    _loadMoreArticles();
  }
  
  @override
  Widget build(BuildContext context) {
    final ui = getAdaptiveFactory(context);
    
    return ui.scaffold(
      appBar: ui.appBar(title: const Text('Articles')),
      body: ListView.builder(
        itemCount: _articles.length + (_hasMore ? 1 : 0),
        itemBuilder: (context, index) {
          if (index == _articles.length) {
            // Load more indicator
            _loadMoreArticles();
            return const Center(
              child: Padding(
                padding: EdgeInsets.all(16),
                child: CircularProgressIndicator(),
              ),
            );
          }
          
          return _ArticleTile(article: _articles[index]);
        },
      ),
    );
  }
  
  Future<void> _loadMoreArticles() async {
    if (_isLoading || !_hasMore) return;
    
    setState(() {
      _isLoading = true;
    });
    
    try {
      final network = getIt<NetworkService>();
      final response = await network.get('/articles', queryParameters: {
        'page': _page,
        'limit': 20,
      });
      
      final newArticles = (response.data['articles'] as List)
          .map((json) => Article.fromJson(json))
          .toList();
      
      setState(() {
        _articles.addAll(newArticles);
        _page++;
        _hasMore = newArticles.length == 20; // Assume 20 per page
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _isLoading = false;
      });
      // Handle error
    }
  }
}
```

### Caching Pattern
```dart
class CachedDataService {
  final NetworkService _network = getIt<NetworkService>();
  final Map<String, CacheEntry> _cache = {};
  final Duration _cacheDuration = Duration(minutes: 5);
  
  Future<T> getCachedData<T>(
    String key,
    Future<T> Function() fetcher,
    T Function(dynamic) parser,
  ) async {
    final entry = _cache[key];
    
    // Check if cache is valid
    if (entry != null && DateTime.now().isBefore(entry.expiry)) {
      return parser(entry.data);
    }
    
    // Fetch fresh data
    final freshData = await fetcher();
    
    // Cache the result
    _cache[key] = CacheEntry(
      data: freshData,
      expiry: DateTime.now().add(_cacheDuration),
    );
    
    return freshData;
  }
  
  void clearCache() {
    _cache.clear();
  }
  
  void removeCacheEntry(String key) {
    _cache.remove(key);
  }
}

class CacheEntry {
  final dynamic data;
  final DateTime expiry;
  
  CacheEntry({required this.data, required this.expiry});
}

// Usage
final dataService = CachedDataService();

final articles = await dataService.getCachedData(
  'articles_page_1',
  () => _network.get('/articles?page=1'),
  (data) => (data['articles'] as List)
      .map((json) => Article.fromJson(json))
      .toList(),
);
```

## ğŸ”— Related Documentation

- **[Getting Started](../getting-started.md)** - Basic setup and first app
- **[Architecture Overview](../architecture.md)** - Understanding the framework structure
- **[Services Documentation](../services/README.md)** - Detailed service guides
- **[UI Systems Guide](../ui-systems/README.md)** - Adaptive UI patterns
- **[Best Practices](../reference/best-practices.md)** - Framework-specific recommendations

These patterns provide a solid foundation for building robust, maintainable Flutter applications with App Shell. Mix and match them based on your specific needs, and don't hesitate to adapt them to your use case! ğŸš€

---

## Migration Guide

*Comprehensive guide for migrating existing Flutter apps with proven strategies*

# Migration Guide: From Existing Flutter Apps

This guide helps you migrate existing Flutter applications to use Flutter App Shell. The migration can be done incrementally, allowing you to adopt App Shell features gradually without rewriting your entire app.

## ğŸ†• InstantDB Migration (v0.3.0+)

**Breaking Change**: Flutter App Shell has migrated from ReaxDB to InstantDB for database operations. This provides real-time synchronization and built-in authentication.

### Key Changes:
- âœ… **Zero code generation** - No more `build_runner` commands needed
- âœ… **Faster development** - No waiting for generated files
- âœ… **Better performance** - 21,000+ writes/sec, 333,333 reads/sec
- âœ… **Built-in encryption** - AES-256 support included
- âœ… **Simpler setup** - Pure Dart implementation

### Migrating to InstantDB:
```dart
// Old Isar approach (with code generation)
@collection
class Document {
  Id id = Isar.autoIncrement;
  @Index()
  late String type;
  late String data;
}

// New InstantDB approach (schemaless)
class Document {
  int? id;
  String type;
  String data;
  
  Map<String, dynamic> toMap() => {
    'id': id,
    'type': type,
    'data': data,
  };
  
  factory Document.fromMap(Map<String, dynamic> map) => Document()
    ..id = map['id']
    ..type = map['type']
    ..data = map['data'];
}
```

### No More MobX or Code Generation:
- **Removed**: `mobx`, `flutter_mobx`, `mobx_codegen`, `build_runner`
- **Added**: `instantdb_flutter` (real-time database with auth)
- **State Management**: Use Signals exclusively (no code generation needed)

## ğŸ¯ Migration Strategies

### Strategy 1: Incremental Adoption (Recommended)
- Add App Shell as a dependency
- Migrate one feature at a time
- Keep existing code working alongside new App Shell code
- Gradually replace existing implementations

### Strategy 2: Complete Migration
- Restructure the entire app to use App Shell patterns
- Best for smaller apps or major refactors
- Requires more upfront work but results in cleaner architecture

### Strategy 3: Hybrid Approach
- Use App Shell for new features only
- Keep existing features as-is
- Good for large, established apps with limited refactor time

### Strategy 4: Plugin-Based Migration
- Convert existing services to App Shell plugins
- Maintain backward compatibility through plugin interfaces
- Gradually migrate while keeping existing architecture
- Perfect for gradual modernization

## ğŸ“‹ Pre-Migration Assessment

Before starting, evaluate your current app:

### Architecture Assessment
```dart
// Current app structure assessment checklist:

// âœ… State Management
// - What are you currently using? (Provider, Bloc, Riverpod, setState)
// - How complex is your state management?
// - Are you ready to migrate to Signals?

// âœ… Navigation
// - Using GoRouter, Navigator 1.0, or other solutions?
// - How many routes do you have?
// - Do you need responsive navigation?

// âœ… Services/Business Logic
// - Where is your business logic located?
// - Do you use dependency injection?
// - How are services structured?

// âœ… UI Components
// - Mostly Material, Cupertino, or custom widgets?
// - Do you need adaptive UI?
// - How much UI customization do you have?

// âœ… Data Management
// - What database/storage solutions are you using?
// - Do you need offline support?
// - Any cloud sync requirements?
```

## ğŸš€ Step-by-Step Migration

### Step 1: Add Flutter App Shell Dependency

Add App Shell to your `pubspec.yaml`:

```yaml
dependencies:
  flutter:
    sdk: flutter
  # Your existing dependencies...
  flutter_app_shell:
    git:
      url: https://github.com/your-org/flutter_ps_app_shell.git
      path: packages/flutter_app_shell
```

Run `flutter pub get` to install the dependency.

### Step 2: Initialize App Shell (Minimal Setup)

Create a minimal App Shell setup alongside your existing app:

```dart
// lib/app_shell_wrapper.dart
import 'package:flutter/material.dart';
import 'package:flutter_app_shell/flutter_app_shell.dart';
import 'existing_app.dart'; // Your current app

class AppShellWrapper extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return FutureBuilder(
      future: _initializeAppShell(),
      builder: (context, snapshot) {
        if (snapshot.connectionState != ConnectionState.done) {
          return MaterialApp(
            home: Scaffold(
              body: Center(child: CircularProgressIndicator()),
            ),
          );
        }
        
        // Return your existing app wrapped with App Shell context
        return AppShellProvider(
          child: ExistingApp(), // Your current app
        );
      },
    );
  }
  
  Future<void> _initializeAppShell() async {
    // Initialize only basic services
    await AppShellCore.initialize(
      enableLogging: true,
      enablePreferences: true,
      // Don't enable other services yet
    );
  }
}

// Update main.dart
void main() {
  runApp(AppShellWrapper());
}
```

### Step 3: Migrate State Management Gradually

#### Option A: Coexist with Existing State Management

```dart
// Keep your existing state management working
class ExistingCounterProvider extends ChangeNotifier {
  int _count = 0;
  int get count => _count;
  
  void increment() {
    _count++;
    notifyListeners();
  }
}

// Add new App Shell signal-based state alongside
class AppShellCounterService {
  final _count = signal(0);
  Signal<int> get count => _count;
  
  void increment() => _count.value++;
}

// Register both in your app
void main() {
  // Existing registration
  runApp(
    ChangeNotifierProvider(
      create: (_) => ExistingCounterProvider(),
      child: AppShellWrapper(),
    ),
  );
  
  // Also register App Shell service
  getIt.registerSingleton<AppShellCounterService>(AppShellCounterService());
}
```

#### Option B: Migrate Existing State to Signals

```dart
// Before: Provider-based state
class CounterProvider extends ChangeNotifier {
  int _count = 0;
  int get count => _count;
  
  void increment() {
    _count++;
    notifyListeners();
  }
}

// After: Signal-based state
class CounterService {
  final _count = signal(0);
  Signal<int> get count => _count;
  
  void increment() => _count.value++;
}

// Migration helper to preserve existing widgets
class CounterProviderCompat extends ChangeNotifier {
  final CounterService _service = getIt<CounterService>();
  late final StreamSubscription _subscription;
  
  CounterProviderCompat() {
    _subscription = _service.count.watch().listen((_) {
      notifyListeners(); // Bridge signals to ChangeNotifier
    });
  }
  
  int get count => _service.count.value;
  void increment() => _service.increment();
  
  @override
  void dispose() {
    _subscription.cancel();
    super.dispose();
  }
}
```

### Step 4: Migrate Navigation

#### From Navigator 1.0 to App Shell Navigation

```dart
// Before: Navigator 1.0
class ExistingApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      initialRoute: '/',
      routes: {
        '/': (context) => HomeScreen(),
        '/profile': (context) => ProfileScreen(),
        '/settings': (context) => SettingsScreen(),
      },
    );
  }
}

// After: App Shell Navigation
class MigratedApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return AppShellApp(
      config: AppConfig(
        title: 'My App',
        routes: [
          AppRoute(
            title: 'Home',
            path: '/',
            icon: Icons.home,
            builder: (context, state) => HomeScreen(),
          ),
          AppRoute(
            title: 'Profile', 
            path: '/profile',
            icon: Icons.person,
            builder: (context, state) => ProfileScreen(),
          ),
          AppRoute(
            title: 'Settings',
            path: '/settings',
            icon: Icons.settings,
            builder: (context, state) => SettingsScreen(),
          ),
        ],
      ),
    );
  }
}
```

#### From GoRouter to App Shell Navigation

```dart
// Before: GoRouter setup
final _router = GoRouter(
  routes: [
    GoRoute(
      path: '/',
      builder: (context, state) => HomeScreen(),
    ),
    GoRoute(
      path: '/profile',
      builder: (context, state) => ProfileScreen(),
    ),
  ],
);

class ExistingApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerConfig: _router,
    );
  }
}

// After: App Shell (GoRouter is used internally)
class MigratedApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return AppShellApp(
      config: AppConfig(
        title: 'My App',
        routes: [
          AppRoute(
            title: 'Home',
            path: '/',
            icon: Icons.home,
            builder: (context, state) => HomeScreen(),
          ),
          AppRoute(
            title: 'Profile',
            path: '/profile', 
            icon: Icons.person,
            builder: (context, state) => ProfileScreen(),
          ),
        ],
      ),
    );
  }
}

// Update navigation calls
// Before:
context.go('/profile');

// After:
getIt<NavigationService>().goToPath('/profile');
```

### Step 5: Migrate UI Components to Adaptive Widgets

#### Gradual Widget Migration

```dart
// Before: Platform-specific widgets
class ExistingForm extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Form')),
      body: Column(
        children: [
          TextField(
            decoration: InputDecoration(labelText: 'Name'),
          ),
          ElevatedButton(
            onPressed: () {},
            child: Text('Submit'),
          ),
        ],
      ),
    );
  }
}

// After: Adaptive widgets
class MigratedForm extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final ui = getAdaptiveFactory(context);
    
    return ui.scaffold(
      appBar: ui.appBar(title: Text('Form')),
      body: Column(
        children: [
          ui.textField(labelText: 'Name'),
          ui.button(
            label: 'Submit',
            onPressed: () {},
          ),
        ],
      ),
    );
  }
}

// Transition strategy: Create adaptive versions alongside existing
class FormV2 extends StatelessWidget {
  final bool useAdaptive;
  
  const FormV2({this.useAdaptive = false});
  
  @override
  Widget build(BuildContext context) {
    if (useAdaptive) {
      return _buildAdaptiveForm(context);
    } else {
      return _buildTraditionalForm(context);
    }
  }
  
  Widget _buildAdaptiveForm(BuildContext context) {
    final ui = getAdaptiveFactory(context);
    return ui.scaffold(/* adaptive implementation */);
  }
  
  Widget _buildTraditionalForm(BuildContext context) {
    return Scaffold(/* existing implementation */);
  }
}
```

### Step 6: Migrate Data Layer

#### From SharedPreferences to PreferencesService

```dart
// Before: Direct SharedPreferences usage
class SettingsManager {
  static const _keyThemeMode = 'theme_mode';
  
  Future<void> saveThemeMode(ThemeMode mode) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_keyThemeMode, mode.toString());
  }
  
  Future<ThemeMode> getThemeMode() async {
    final prefs = await SharedPreferences.getInstance();
    final value = prefs.getString(_keyThemeMode);
    // Manual parsing logic...
  }
}

// After: PreferencesService
class SettingsService {
  final PreferencesService _prefs = getIt<PreferencesService>();
  
  Future<void> saveThemeMode(ThemeMode mode) async {
    await _prefs.setEnum('theme_mode', mode);
  }
  
  Future<ThemeMode> getThemeMode() async {
    return await _prefs.getEnum('theme_mode', ThemeMode.system);
  }
  
  // Even better: Reactive preferences
  Signal<ThemeMode> get themeModeSignal => _prefs.getEnumSignal('theme_mode', ThemeMode.system);
}
```

#### From SQLite/Custom DB to DatabaseService

```dart
// Before: sqflite or custom database
class TodoDatabase {
  static Database? _database;
  
  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB();
    return _database!;
  }
  
  Future<List<Todo>> getTodos() async {
    final db = await database;
    final maps = await db.query('todos');
    return maps.map((map) => Todo.fromMap(map)).toList();
  }
  
  Future<void> insertTodo(Todo todo) async {
    final db = await database;
    await db.insert('todos', todo.toMap());
  }
}

// After: DatabaseService
class TodoService {
  final DatabaseService _db = getIt<DatabaseService>();
  
  Future<List<Todo>> getTodos() async {
    final documents = await _db.findByType('todos');
    return documents.map((doc) => Todo.fromDocument(doc)).toList();
  }
  
  Future<void> createTodo(Todo todo) async {
    await _db.create('todos', todo.toJson());
  }
  
  // Reactive queries
  Stream<List<Todo>> watchTodos() {
    return _db.watchByType('todos').map((documents) =>
        documents.map((doc) => Todo.fromDocument(doc)).toList());
  }
}
```

### Step 7: Migrate to Plugin Architecture (Optional)

Convert your existing services to plugins for better modularity:

```dart
// Before: Direct service registration
class MyAnalyticsService {
  static final instance = MyAnalyticsService._();
  MyAnalyticsService._();
  
  void track(String event) { /* ... */ }
}

// Register directly
getIt.registerSingleton<MyAnalyticsService>(MyAnalyticsService.instance);

// After: Plugin-based service
class AnalyticsPlugin extends BaseServicePlugin {
  @override
  String get id => 'com.myapp.analytics';
  
  @override
  String get name => 'Analytics Service';
  
  @override
  List<Type> get serviceTypes => [MyAnalyticsService];
  
  @override
  Future<void> registerServices(GetIt getIt) async {
    getIt.registerSingleton<MyAnalyticsService>(MyAnalyticsService.instance);
  }
}

// Register via plugin system
runShellApp(
  () async => AppConfig(...),
  enablePlugins: true,
  pluginConfiguration: {
    'manualPlugins': [AnalyticsPlugin()],
  },
);
```

**Benefits of Plugin Migration:**
- Better organization and modularity
- Health monitoring and status tracking
- Auto-discovery and dependency resolution
- Consistent initialization patterns
- Real-time debugging in Service Inspector

### Step 8: Add Cloud Sync (Optional)

If you want to add cloud sync capabilities:

```dart
// Initialize InstantDB service
final db = DatabaseService.instance;
// Automatically configured from environment variables
// Real-time sync enabled by default

// Your existing local data will automatically sync to cloud
// No changes needed to your service calls
final todos = await todoService.getTodos(); // Automatically syncs
```

## ğŸ”§ Migration Helpers and Tools

### Compatibility Layers

Create compatibility layers to ease migration:

```dart
// Provider -> Signal compatibility
class SignalChangeNotifier<T> extends ChangeNotifier {
  final Signal<T> _signal;
  late final StreamSubscription _subscription;
  
  SignalChangeNotifier(this._signal) {
    _subscription = _signal.watch().listen((_) {
      notifyListeners();
    });
  }
  
  T get value => _signal.value;
  set value(T newValue) => _signal.value = newValue;
  
  @override
  void dispose() {
    _subscription.cancel();
    super.dispose();
  }
}

// Usage
final counterSignal = signal(0);
final counterNotifier = SignalChangeNotifier(counterSignal);

// Existing Provider widgets still work
ChangeNotifierProvider.value(
  value: counterNotifier,
  child: ExistingWidget(),
)
```

### Data Migration Utilities

```dart
// Migrate existing data to new format
class DataMigrationService {
  final DatabaseService _db = getIt<DatabaseService>();
  
  Future<void> migrateFromSQLite() async {
    // Read existing SQLite data
    final oldDatabase = await openDatabase('old_app.db');
    final oldTodos = await oldDatabase.query('todos');
    
    // Migrate to new format
    for (final todoMap in oldTodos) {
      await _db.create('todos', {
        'title': todoMap['title'],
        'completed': todoMap['completed'] == 1,
        'createdAt': DateTime.fromMillisecondsSinceEpoch(
          todoMap['created_at'] as int
        ).toIso8601String(),
      });
    }
    
    await oldDatabase.close();
  }
  
  Future<void> migrateFromSharedPreferences() async {
    final prefs = await SharedPreferences.getInstance();
    final prefsService = getIt<PreferencesService>();
    
    // Migrate settings
    final themeMode = prefs.getString('theme_mode');
    if (themeMode != null) {
      await prefsService.setString('theme_mode', themeMode);
      await prefs.remove('theme_mode');
    }
    
    // Migrate other preferences...
  }
}
```

## ğŸ“Š Migration Checklist

### Phase 1: Foundation
- [ ] Add Flutter App Shell dependency
- [ ] Initialize basic App Shell services
- [ ] Verify existing app still works
- [ ] Add basic logging and preferences

### Phase 2: Services
- [ ] Identify business logic in widgets
- [ ] Create App Shell services for core functionality
- [ ] Migrate state management to Signals
- [ ] Add service registration to main.dart

### Phase 3: Navigation
- [ ] Map existing routes to App Route format
- [ ] Update navigation calls to use NavigationService
- [ ] Test responsive navigation behavior
- [ ] Migrate deep linking if applicable

### Phase 4: UI Components
- [ ] Identify widgets that benefit from adaptive behavior
- [ ] Create adaptive versions of key components
- [ ] Test on different platforms (Material/Cupertino/ForUI)
- [ ] Update widget composition patterns

### Phase 5: Data Layer
- [ ] Migrate preferences to PreferencesService
- [ ] Migrate database to DatabaseService
- [ ] Add reactive data queries
- [ ] Test offline-first behavior

### Phase 6: Advanced Features
- [ ] Add cloud sync if needed
- [ ] Implement service inspector for debugging
- [ ] Add performance monitoring
- [ ] Set up comprehensive testing

### Phase 7: Cleanup
- [ ] Remove old dependencies
- [ ] Delete unused compatibility layers
- [ ] Update documentation
- [ ] Train team on new patterns

## ğŸš¨ Common Migration Pitfalls

### 1. Trying to Migrate Everything at Once
```dart
// âŒ Bad - Big bang migration
void main() {
  // Trying to change everything at once
  runApp(CompletelyNewAppShellApp());
}

// âœ… Good - Gradual migration
void main() {
  runApp(
    AppShellWrapper(
      child: ExistingAppWithSomeNewFeatures(),
    ),
  );
}
```

### 2. Not Planning for Coexistence
```dart
// âŒ Bad - Assuming old and new can't coexist
class MyService {
  // Can only use new OR old, not both
}

// âœ… Good - Plan for transition period
class MyService {
  final bool _useAppShellPatterns;
  final OldStateManager? _oldState;
  final Signal<State>? _newState;
  
  MyService({bool useAppShell = false}) : _useAppShellPatterns = useAppShell {
    if (useAppShell) {
      _newState = signal(initialState);
    } else {
      _oldState = OldStateManager();
    }
  }
}
```

### 3. Ignoring Performance During Migration
```dart
// âŒ Bad - Creating wrapper layers that hurt performance
class PerformanceKillerWrapper extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Watch((context) { // Unnecessary reactive wrapper
      return Consumer<OldProvider>( // Old provider
        builder: (context, provider, child) {
          return ExpensiveWidget(); // Rebuilds too often
        },
      );
    });
  }
}

// âœ… Good - Efficient migration
class EfficientMigration extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Choose one pattern, don't wrap both
    final useNewPattern = shouldUseNewPattern();
    
    if (useNewPattern) {
      return Watch((context) => NewWidget());
    } else {
      return Consumer<OldProvider>(
        builder: (context, provider, child) => OldWidget(),
      );
    }
  }
}
```

## ğŸ“ˆ Measuring Migration Success

### Metrics to Track
```dart
// Performance metrics
- App startup time
- Memory usage
- Widget rebuild frequency
- Navigation performance

// Code quality metrics
- Lines of code reduced
- Test coverage improvement
- Number of services created
- Dependency graph simplification

// User experience metrics
- Crash reduction
- Feature adoption
- User satisfaction
- Support ticket reduction
```

### Migration Progress Tracking
```dart
class MigrationTracker {
  static final metrics = {
    'total_widgets': 150,
    'adaptive_widgets': 45,     // 30% migrated
    'total_screens': 20,
    'app_shell_screens': 8,     // 40% migrated
    'old_state_management': 12,
    'new_state_management': 8,  // 40% migrated
  };
  
  static double get adaptiveUIProgress => 
      metrics['adaptive_widgets']! / metrics['total_widgets']!;
      
  static double get stateManagementProgress =>
      metrics['new_state_management']! / 
      (metrics['old_state_management']! + metrics['new_state_management']!);
}
```

## ğŸ”— Additional Resources

- **[Getting Started Guide](getting-started.md)** - Basic App Shell setup
- **[Architecture Overview](architecture.md)** - Understanding App Shell patterns
- **[Common Patterns](examples/patterns.md)** - Implementation examples
- **[Best Practices](reference/best-practices.md)** - Recommended approaches
- **[Troubleshooting](reference/troubleshooting.md)** - Common issues and solutions

Remember: migration is a journey, not a destination. Take it one step at a time, and don't be afraid to keep what works while gradually adopting what's better! ğŸš€

---

## Best Practices & Guidelines

*Guidelines for maintainable, performant code with common pitfalls to avoid*

# Best Practices & Guidelines

This guide provides recommendations, best practices, and common pitfalls to avoid when building applications with Flutter App Shell. Following these guidelines will help you build maintainable, performant, and user-friendly applications.

## ğŸ¯ Core Principles

### 1. Service-First Architecture
Always think in terms of services and separation of concerns:

```dart
// âœ… Good - Business logic in service
class TodoService {
  final DatabaseService _db = getIt<DatabaseService>();
  
  Future<List<Todo>> getTodos() async {
    final documents = await _db.findByType('todos');
    return documents.map((doc) => Todo.fromDocument(doc)).toList();
  }
  
  Future<void> createTodo(String title) async {
    await _db.create('todos', {
      'title': title,
      'completed': false,
      'createdAt': DateTime.now().toIso8601String(),
    });
  }
}

// âŒ Bad - Business logic in widget
class TodoWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final db = getIt<DatabaseService>();
    
    return FutureBuilder(
      future: db.findByType('todos').then((documents) {
        // Business logic mixed with UI
        return documents
            .where((doc) => !doc.isDeleted)
            .map((doc) => Todo.fromDocument(doc))
            .toList();
      }),
      builder: (context, snapshot) { /* ... */ },
    );
  }
}
```

### 2. Reactive State Management
Use Signals consistently for reactive state:

```dart
// âœ… Good - Reactive with Signals
class CounterService {
  final _count = signal(0);
  Signal<int> get count => _count;
  
  void increment() => _count.value++;
  void decrement() => _count.value--;
}

// UI automatically updates
Watch((context) => Text('Count: ${counterService.count.value}'))

// âŒ Bad - Manual state management
class CounterWidget extends StatefulWidget {
  @override
  _CounterWidgetState createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<CounterWidget> {
  int _count = 0;
  
  @override
  Widget build(BuildContext context) {
    return Text('Count: $_count'); // Won't update from other widgets
  }
}
```

### 3. Adaptive UI First
Always use the adaptive widget factory:

```dart
// âœ… Good - Adaptive UI
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final ui = getAdaptiveFactory(context);
    
    return ui.scaffold(
      body: ui.button(
        label: 'Adaptive Button',
        onPressed: () {},
      ),
    );
  }
}

// âŒ Bad - Platform-specific UI
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: ElevatedButton( // Won't adapt to UI system changes
        onPressed: () {},
        child: Text('Platform Button'),
      ),
    );
  }
}
```

## ğŸ—ï¸ Architecture Best Practices

### Service Organization
```dart
// âœ… Good - Clear service boundaries
class UserService {
  // Only user-related operations
  Future<User> getCurrentUser() async { /* */ }
  Future<void> updateProfile(UserProfile profile) async { /* */ }
  Future<void> uploadAvatar(File image) async { /* */ }
}

class TodoService {
  // Only todo-related operations
  Future<List<Todo>> getTodos() async { /* */ }
  Future<void> createTodo(Todo todo) async { /* */ }
  Future<void> updateTodo(String id, Todo todo) async { /* */ }
}

// âŒ Bad - Mixed responsibilities
class DataService {
  // Too many responsibilities in one service
  Future<User> getCurrentUser() async { /* */ }
  Future<List<Todo>> getTodos() async { /* */ }
  Future<void> sendEmail(String to, String subject) async { /* */ }
  Future<void> uploadFile(File file) async { /* */ }
}
```

### Service Dependencies
```dart
// âœ… Good - Clear dependencies through constructor or getter
class UserService {
  final DatabaseService _db = getIt<DatabaseService>();
  final AuthenticationService _auth = getIt<AuthenticationService>();
  
  Future<User?> getCurrentUser() async {
    final userId = _auth.currentUser.value?.id;
    if (userId == null) return null;
    
    final doc = await _db.findById('users', userId);
    return doc != null ? User.fromDocument(doc) : null;
  }
}

// âŒ Bad - Hidden dependencies
class UserService {
  Future<User?> getCurrentUser() async {
    // Hidden dependency on getIt
    final auth = getIt<AuthenticationService>();
    final db = getIt<DatabaseService>();
    // This makes testing harder and dependencies unclear
  }
}
```

### Error Handling
```dart
// âœ… Good - Consistent error handling with proper logging
class TodoService {
  static final _logger = Logger('TodoService');
  
  Future<List<Todo>> getTodos() async {
    try {
      _logger.debug('Fetching todos');
      final documents = await _db.findByType('todos');
      _logger.info('Fetched ${documents.length} todos');
      return documents.map((doc) => Todo.fromDocument(doc)).toList();
    } catch (e, stackTrace) {
      _logger.error('Failed to fetch todos', e, stackTrace);
      throw TodoServiceException('Unable to load todos', e);
    }
  }
}

// Custom exception types
class TodoServiceException implements Exception {
  final String message;
  final dynamic cause;
  
  TodoServiceException(this.message, [this.cause]);
  
  @override
  String toString() => 'TodoServiceException: $message';
}

// âŒ Bad - Silent failures or generic exceptions
class TodoService {
  Future<List<Todo>> getTodos() async {
    try {
      final documents = await _db.findByType('todos');
      return documents.map((doc) => Todo.fromDocument(doc)).toList();
    } catch (e) {
      print('Error: $e'); // Poor logging
      return []; // Silent failure
    }
  }
}
```

## ğŸ¨ UI Best Practices

### Responsive Design
```dart
// âœ… Good - Responsive design with adaptive breakpoints
class ResponsiveWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        if (constraints.maxWidth < 600) {
          return _MobileLayout();
        } else if (constraints.maxWidth < 1200) {
          return _TabletLayout();
        } else {
          return _DesktopLayout();
        }
      },
    );
  }
}

// âŒ Bad - Fixed layout that doesn't adapt
class FixedWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Row( // Always horizontal, even on small screens
      children: [
        Container(width: 300, child: Sidebar()),
        Expanded(child: Content()),
      ],
    );
  }
}
```

### State Management in UI
```dart
// âœ… Good - Separate presentation from business logic
class TodoListScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final todoService = getIt<TodoService>();
    final ui = getAdaptiveFactory(context);
    
    return Watch((context) {
      final todos = todoService.todos.value;
      final isLoading = todoService.isLoading.value;
      
      if (isLoading) {
        return ui.scaffold(
          body: Center(child: CircularProgressIndicator()),
        );
      }
      
      return ui.scaffold(
        body: ListView.builder(
          itemCount: todos.length,
          itemBuilder: (context, index) => TodoTile(todo: todos[index]),
        ),
      );
    });
  }
}

// âŒ Bad - Mixed state and business logic in widget
class TodoListScreen extends StatefulWidget {
  @override
  _TodoListScreenState createState() => _TodoListScreenState();
}

class _TodoListScreenState extends State<TodoListScreen> {
  List<Todo> _todos = [];
  bool _isLoading = false;
  
  @override
  void initState() {
    super.initState();
    _loadTodos(); // Business logic in widget
  }
  
  Future<void> _loadTodos() async {
    setState(() => _isLoading = true);
    final db = getIt<DatabaseService>();
    final documents = await db.findByType('todos');
    setState(() {
      _todos = documents.map((doc) => Todo.fromDocument(doc)).toList();
      _isLoading = false;
    });
  }
}
```

### Widget Composition
```dart
// âœ… Good - Small, focused, reusable widgets
class TodoTile extends StatelessWidget {
  final Todo todo;
  final VoidCallback? onToggle;
  final VoidCallback? onDelete;
  
  const TodoTile({
    Key? key,
    required this.todo,
    this.onToggle,
    this.onDelete,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    final ui = getAdaptiveFactory(context);
    
    return ui.listTile(
      title: Text(todo.title),
      leading: ui.checkbox(
        value: todo.completed,
        onChanged: onToggle != null ? (_) => onToggle!() : null,
      ),
      trailing: onDelete != null
          ? ui.iconButton(
              icon: Icon(Icons.delete),
              onPressed: onDelete,
            )
          : null,
    );
  }
}

// âŒ Bad - Large, monolithic widgets
class TodoScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(/* complex app bar logic */),
      body: Column(
        children: [
          Container(/* complex header */),
          Expanded(
            child: ListView.builder(
              itemBuilder: (context, index) {
                // All todo tile logic inline
                return Container(
                  padding: EdgeInsets.all(16),
                  child: Row(
                    children: [
                      Checkbox(/* inline logic */),
                      Expanded(child: Text(/* complex text logic */)),
                      IconButton(/* inline delete logic */),
                    ],
                  ),
                );
              },
            ),
          ),
          Container(/* complex footer */),
        ],
      ),
    );
  }
}
```

## ğŸ“Š Data Management Best Practices

### Local-First with Cloud Sync
```dart
// âœ… Good - Local-first approach
class ArticleService {
  final DatabaseService _db = getIt<DatabaseService>();
  final NetworkService _network = getIt<NetworkService>();
  
  Future<List<Article>> getArticles({bool forceRefresh = false}) async {
    // 1. Always return local data first
    final localArticles = await _db.findByType('articles');
    
    if (localArticles.isNotEmpty && !forceRefresh) {
      // Return local data immediately, sync in background
      _syncInBackground();
      return localArticles.map((doc) => Article.fromDocument(doc)).toList();
    }
    
    // 2. If no local data or force refresh, try network
    try {
      return await _fetchFromNetwork();
    } catch (e) {
      // 3. Network failed, return local data as fallback
      return localArticles.map((doc) => Article.fromDocument(doc)).toList();
    }
  }
  
  Future<void> _syncInBackground() async {
    try {
      await _fetchFromNetwork();
    } catch (e) {
      // Background sync failed, but that's OK
      print('Background sync failed: $e');
    }
  }
}

// âŒ Bad - Network-first approach
class ArticleService {
  Future<List<Article>> getArticles() async {
    try {
      // Always hits network first, slow and unreliable
      final response = await _network.get('/articles');
      return (response.data as List)
          .map((json) => Article.fromJson(json))
          .toList();
    } catch (e) {
      // No fallback to local data
      throw Exception('Failed to load articles');
    }
  }
}
```

### Data Validation
```dart
// âœ… Good - Validate data at service boundaries
class UserService {
  Future<void> createUser(User user) async {
    // Validate before saving
    _validateUser(user);
    
    await _db.create('users', user.toJson());
  }
  
  void _validateUser(User user) {
    if (user.email.isEmpty) {
      throw ValidationException('Email is required');
    }
    
    if (!user.email.contains('@')) {
      throw ValidationException('Invalid email format');
    }
    
    if (user.name.length < 2) {
      throw ValidationException('Name must be at least 2 characters');
    }
  }
}

// âŒ Bad - No validation or validation in wrong place
class UserService {
  Future<void> createUser(User user) async {
    // No validation - invalid data reaches database
    await _db.create('users', user.toJson());
  }
}

// UI should not be the only validation layer
class UserForm extends StatelessWidget {
  Widget build(BuildContext context) {
    return TextFormField(
      validator: (value) {
        // Validation only in UI - can be bypassed
        if (value?.isEmpty ?? true) return 'Email required';
        return null;
      },
    );
  }
}
```

### Optimistic Updates
```dart
// âœ… Good - Optimistic updates with rollback
class TodoService {
  final _todos = signal<List<Todo>>([]);
  
  Future<void> toggleTodo(String todoId) async {
    final todos = _todos.value;
    final todoIndex = todos.indexWhere((t) => t.id == todoId);
    if (todoIndex == -1) return;
    
    final originalTodo = todos[todoIndex];
    final updatedTodo = originalTodo.copyWith(completed: !originalTodo.completed);
    
    // Optimistic update - update UI immediately
    final updatedTodos = List<Todo>.from(todos);
    updatedTodos[todoIndex] = updatedTodo;
    _todos.value = updatedTodos;
    
    try {
      // Persist to storage
      await _db.update('todos', todoId, updatedTodo.toJson());
      
      // Sync to cloud if available
      await _syncToCloud(updatedTodo);
    } catch (e) {
      // Rollback on failure
      _todos.value = todos;
      throw TodoUpdateException('Failed to update todo');
    }
  }
}

// âŒ Bad - No optimistic updates, slow UX
class TodoService {
  Future<void> toggleTodo(String todoId) async {
    try {
      // Update storage first - UI waits
      await _db.update('todos', todoId, {'completed': true});
      
      // Sync to cloud - UI still waiting
      await _network.put('/todos/$todoId', {'completed': true});
      
      // Finally update UI
      _loadTodos();
    } catch (e) {
      // Error - no visual feedback until this point
      throw Exception('Update failed');
    }
  }
}
```

## ğŸš€ Performance Best Practices

### Efficient List Rendering
```dart
// âœ… Good - Efficient list with keys and minimal rebuilds
class TodoList extends StatelessWidget {
  final List<Todo> todos;
  
  const TodoList({Key? key, required this.todos}) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: todos.length,
      itemBuilder: (context, index) {
        final todo = todos[index];
        return TodoTile(
          key: ValueKey(todo.id), // Stable key for animations
          todo: todo,
        );
      },
    );
  }
}

class TodoTile extends StatelessWidget {
  final Todo todo;
  
  const TodoTile({Key? key, required this.todo}) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    // Minimal, focused widget that only rebuilds when todo changes
    return ListTile(
      title: Text(todo.title),
      leading: Checkbox(
        value: todo.completed,
        onChanged: (_) => _toggleTodo(todo.id),
      ),
    );
  }
}

// âŒ Bad - Inefficient list rendering
class TodoList extends StatefulWidget {
  @override
  _TodoListState createState() => _TodoListState();
}

class _TodoListState extends State<TodoList> {
  @override
  Widget build(BuildContext context) {
    final todoService = getIt<TodoService>();
    
    return Watch((context) {
      final todos = todoService.todos.value;
      
      return Column(
        children: todos.map((todo) {
          // No keys - poor animation performance
          // New widget instance on every rebuild
          return ListTile(
            title: Text(todo.title),
            leading: Checkbox(
              value: todo.completed,
              onChanged: (_) {
                // Inline logic causes entire list to rebuild
                todoService.toggleTodo(todo.id);
              },
            ),
          );
        }).toList(),
      );
    });
  }
}
```

### Memory Management
```dart
// âœ… Good - Proper disposal of resources
class ImageGalleryService {
  final List<ImageProvider> _imageCache = [];
  StreamSubscription? _subscription;
  
  void initialize() {
    _subscription = someStream.listen((data) {
      // Handle data
    });
  }
  
  void dispose() {
    _subscription?.cancel();
    _subscription = null;
    
    // Clear image cache
    for (final provider in _imageCache) {
      provider.evict();
    }
    _imageCache.clear();
  }
}

// âŒ Bad - Memory leaks
class ImageGalleryService {
  final List<ImageProvider> _imageCache = [];
  StreamSubscription? _subscription;
  
  void initialize() {
    _subscription = someStream.listen((data) {
      // Handle data
    });
  }
  
  // No dispose method - memory leak
}
```

### Efficient Signals Usage
```dart
// âœ… Good - Granular signals
class UserService {
  final _name = signal('');
  final _email = signal('');
  final _avatar = signal<String?>(null);
  
  Signal<String> get name => _name;
  Signal<String> get email => _email;
  Signal<String?> get avatar => _avatar;
  
  // Each property can be watched independently
}

// UI only rebuilds when specific property changes
Watch((context) => Text(userService.name.value)) // Only rebuilds when name changes
Watch((context) => Text(userService.email.value)) // Only rebuilds when email changes

// âŒ Bad - Coarse-grained signals
class UserService {
  final _user = signal<User?>(null);
  Signal<User?> get user => _user;
  
  void updateName(String newName) {
    final currentUser = _user.value;
    if (currentUser != null) {
      // Entire user object changes - all watchers rebuild
      _user.value = currentUser.copyWith(name: newName);
    }
  }
}

// All UI watching user rebuilds even for small changes
Watch((context) {
  final user = userService.user.value;
  return Column(
    children: [
      Text(user?.name ?? ''), // Rebuilds when ANY user property changes
      Text(user?.email ?? ''), // Rebuilds when ANY user property changes
      UserAvatar(url: user?.avatar), // Rebuilds when ANY user property changes
    ],
  );
})
```

## ğŸ§ª Testing Best Practices

### Service Testing
```dart
// âœ… Good - Isolated service testing with mocks
void main() {
  group('TodoService', () {
    late TodoService todoService;
    late MockDatabaseService mockDb;
    late MockNetworkService mockNetwork;
    
    setUp(() {
      mockDb = MockDatabaseService();
      mockNetwork = MockNetworkService();
      
      // Register mocks
      getIt.registerSingleton<DatabaseService>(mockDb);
      getIt.registerSingleton<NetworkService>(mockNetwork);
      
      todoService = TodoService();
    });
    
    tearDown(() {
      getIt.reset();
    });
    
    test('should create todo and save to database', () async {
      // Arrange
      when(mockDb.create(any, any)).thenAnswer((_) async => 'todo-id');
      
      // Act
      await todoService.createTodo('Test Todo');
      
      // Assert
      verify(mockDb.create('todos', {
        'title': 'Test Todo',
        'completed': false,
        'createdAt': any,
      })).called(1);
    });
  });
}

// âŒ Bad - Testing with real dependencies
void main() {
  test('should create todo', () async {
    final todoService = TodoService();
    
    // Uses real database and network - slow, unreliable, affects other tests
    await todoService.createTodo('Test Todo');
    
    // Hard to verify what actually happened
    expect(true, true); // Weak assertion
  });
}
```

### Widget Testing
```dart
// âœ… Good - Widget testing with service mocks
void main() {
  testWidgets('TodoList should display todos', (tester) async {
    // Arrange
    final mockTodoService = MockTodoService();
    when(mockTodoService.todos).thenReturn(signal([
      Todo(id: '1', title: 'Test Todo 1', completed: false),
      Todo(id: '2', title: 'Test Todo 2', completed: true),
    ]));
    
    await tester.pumpWidget(
      TestApp(
        services: {'TodoService': mockTodoService},
        child: TodoListScreen(),
      ),
    );
    
    // Assert
    expect(find.text('Test Todo 1'), findsOneWidget);
    expect(find.text('Test Todo 2'), findsOneWidget);
    expect(find.byType(Checkbox), findsNWidgets(2));
  });
}

// âŒ Bad - Widget testing without proper setup
void main() {
  testWidgets('TodoList test', (tester) async {
    await tester.pumpWidget(TodoListScreen()); // No service setup - will crash
    
    expect(find.byType(TodoListScreen), findsOneWidget); // Weak test
  });
}
```

## ğŸ”’ Security Best Practices

### Input Validation
```dart
// âœ… Good - Server-side style validation
class UserService {
  Future<void> updateEmail(String email) async {
    // Always validate inputs
    if (!_isValidEmail(email)) {
      throw ValidationException('Invalid email format');
    }
    
    // Sanitize if needed
    final sanitizedEmail = email.trim().toLowerCase();
    
    await _db.update('users', _currentUserId, {
      'email': sanitizedEmail,
    });
  }
  
  bool _isValidEmail(String email) {
    return RegExp(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
        .hasMatch(email);
  }
}

// âŒ Bad - Trusting client-side validation only
class UserService {
  Future<void> updateEmail(String email) async {
    // No validation - trusts input
    await _db.update('users', _currentUserId, {
      'email': email, // Could be malicious
    });
  }
}
```

### Sensitive Data Handling
```dart
// âœ… Good - Proper sensitive data handling
class AuthenticationService {
  Future<void> storeAuthToken(String token) async {
    // Use secure storage for sensitive data
    await _secureStorage.write(key: 'auth_token', value: token);
    
    // Never log sensitive data
    _logger.info('Auth token stored successfully');
  }
  
  Future<void> signOut() async {
    // Clear sensitive data on sign out
    await _secureStorage.delete(key: 'auth_token');
    await _secureStorage.delete(key: 'refresh_token');
    
    // Clear any cached user data
    _currentUser.value = null;
  }
}

// âŒ Bad - Insecure data handling
class AuthenticationService {
  Future<void> storeAuthToken(String token) async {
    // Storing sensitive data in regular preferences
    await _prefs.setString('auth_token', token);
    
    // Logging sensitive data
    _logger.debug('Stored token: $token'); // NEVER DO THIS
  }
}
```

## ğŸ“‹ Code Organization

### File Structure
```
lib/
â”œâ”€â”€ services/           # Business logic services
â”‚   â”œâ”€â”€ todo_service.dart
â”‚   â”œâ”€â”€ user_service.dart
â”‚   â””â”€â”€ notification_service.dart
â”œâ”€â”€ models/            # Data models
â”‚   â”œâ”€â”€ todo.dart
â”‚   â”œâ”€â”€ user.dart
â”‚   â””â”€â”€ notification.dart
â”œâ”€â”€ screens/           # UI screens
â”‚   â”œâ”€â”€ todo/
â”‚   â”‚   â”œâ”€â”€ todo_list_screen.dart
â”‚   â”‚   â”œâ”€â”€ todo_detail_screen.dart
â”‚   â”‚   â””â”€â”€ widgets/
â”‚   â”‚       â”œâ”€â”€ todo_tile.dart
â”‚   â”‚       â””â”€â”€ todo_form.dart
â”‚   â””â”€â”€ user/
â”‚       â”œâ”€â”€ profile_screen.dart
â”‚       â””â”€â”€ settings_screen.dart
â”œâ”€â”€ utils/             # Utilities and helpers
â”‚   â”œâ”€â”€ validators.dart
â”‚   â”œâ”€â”€ constants.dart
â”‚   â””â”€â”€ extensions.dart
â””â”€â”€ main.dart
```

### Import Organization
```dart
// âœ… Good - Organized imports
// Dart imports
import 'dart:async';
import 'dart:io';

// Flutter imports
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

// Package imports
import 'package:flutter_app_shell/flutter_app_shell.dart';
import 'package:get_it/get_it.dart';

// Project imports
import '../models/todo.dart';
import '../services/todo_service.dart';
import 'widgets/todo_tile.dart';

// âŒ Bad - Disorganized imports
import '../services/todo_service.dart';
import 'package:flutter/material.dart';
import '../models/todo.dart';
import 'dart:async';
import 'package:get_it/get_it.dart';
import 'widgets/todo_tile.dart';
import 'package:flutter_app_shell/flutter_app_shell.dart';
```

## ğŸš¨ Common Pitfalls to Avoid

### 1. Mixing UI and Business Logic
```dart
// âŒ Bad
class TodoScreen extends StatefulWidget {
  @override
  _TodoScreenState createState() => _TodoScreenState();
}

class _TodoScreenState extends State<TodoScreen> {
  List<Todo> _todos = [];
  
  @override
  void initState() {
    super.initState();
    _loadTodos(); // Business logic in widget
  }
  
  Future<void> _loadTodos() async {
    final db = getIt<DatabaseService>();
    final documents = await db.findByType('todos');
    
    // Business logic in widget
    final todos = documents
        .where((doc) => !doc.isDeleted)
        .map((doc) => Todo.fromDocument(doc))
        .where((todo) => todo.isActive)
        .toList();
    
    setState(() => _todos = todos);
  }
}
```

### 2. Not Using Adaptive UI
```dart
// âŒ Bad - Platform-specific widgets
return Scaffold(
  body: Column(
    children: [
      ElevatedButton(onPressed: () {}, child: Text('Submit')),
      TextField(decoration: InputDecoration(labelText: 'Name')),
    ],
  ),
);

// âœ… Good - Adaptive widgets
final ui = getAdaptiveFactory(context);
return ui.scaffold(
  body: Column(
    children: [
      ui.button(label: 'Submit', onPressed: () {}),
      ui.textField(labelText: 'Name'),
    ],
  ),
);
```

### 3. Forgetting Watch Widgets
```dart
// âŒ Bad - Won't update when signal changes
class CounterWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final counter = getIt<CounterService>();
    return Text('Count: ${counter.count.value}'); // Static value
  }
}

// âœ… Good - Reactive to signal changes
class CounterWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final counter = getIt<CounterService>();
    return Watch((context) => Text('Count: ${counter.count.value}'));
  }
}
```

### 4. Memory Leaks with Streams
```dart
// âŒ Bad - Stream subscription not cancelled
class MyWidget extends StatefulWidget {
  @override
  _MyWidgetState createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  @override
  void initState() {
    super.initState();
    someStream.listen((data) {
      // Handle data
    }); // Subscription never cancelled - memory leak
  }
}

// âœ… Good - Proper subscription management
class _MyWidgetState extends State<MyWidget> {
  StreamSubscription? _subscription;
  
  @override
  void initState() {
    super.initState();
    _subscription = someStream.listen((data) {
      // Handle data
    });
  }
  
  @override
  void dispose() {
    _subscription?.cancel();
    super.dispose();
  }
}
```

## ğŸ”— Related Resources

- **[Getting Started](../getting-started.md)** - Basic setup and first app
- **[Architecture Overview](../architecture.md)** - Understanding the framework
- **[Common Patterns](../examples/patterns.md)** - Practical implementation examples
- **[Testing Guide](../advanced/testing.md)** - Comprehensive testing strategies
- **[Performance Guide](../advanced/performance.md)** - Optimization techniques

Following these best practices will help you build maintainable, performant, and reliable Flutter applications with App Shell. Remember: good architecture and patterns are more important than clever code! ğŸš€

---

## Database Service

*NoSQL document database with reactive queries, cloud sync, and offline-first architecture*

# Database Service

The Database Service provides a powerful NoSQL document database with reactive queries, cloud synchronization, and offline-first architecture. Built on **InstantDB** for real-time local storage with automatic cloud sync.

## ğŸš€ Quick Start

### Basic Usage
```dart
final db = getIt<DatabaseService>();

// Create a document
final todoId = await db.create('todos', {
  'title': 'Buy groceries',
  'completed': false,
  'dueDate': DateTime.now().add(Duration(days: 1)).toIso8601String(),
});

// Find documents
final todos = await db.findByType('todos');

// Update a document
await db.update(todoId, {
  'completed': true,
});

// Delete a document
await db.delete(todoId);
```

### Reactive Queries
```dart
// Watch for changes in real-time
db.watchByType('todos').listen((documents) {
  print('Todos updated: ${documents.length} items');
});

// Use in UI with StreamBuilder
StreamBuilder<List<Map<String, dynamic>>>(
  stream: db.watchByType('todos'),
  builder: (context, snapshot) {
    if (!snapshot.hasData) return CircularProgressIndicator();
    
    final todos = snapshot.data!;
    return ListView.builder(
      itemCount: todos.length,
      itemBuilder: (context, index) {
        final todo = todos[index];
        return ListTile(
          title: Text(todo['title']),
          trailing: Checkbox(
            value: todo['completed'] ?? false,
            onChanged: (value) => _toggleTodo(todo['_id'], value),
          ),
        );
      },
    );
  },
)
```

## ğŸ“Š Document Model

### Document Structure
```dart
class Document {
  int? id;                   // Unique identifier
  String type;               // Document type (e.g., 'todos', 'users')  
  String data;               // JSON data as string
  List<String> tags;         // Optional tags for categorization
  DateTime createdAt;        // Creation timestamp
  DateTime updatedAt;        // Last update timestamp
  int version;               // Version number for conflict resolution
  bool isDeleted;            // Soft delete flag
}
```

### Creating Documents
```dart
// Simple document
final id = await db.create('notes', {
  'title': 'My Note',
  'content': 'Note content here',
});

// Document with tags
final id = await db.create('articles', {
  'title': 'Flutter Best Practices',
  'content': 'Article content...',
}, tags: ['flutter', 'development', 'mobile']);
```

## ğŸ” Querying Data

### Basic Queries
```dart
// Find all documents of a type
final allTodos = await db.findByType('todos');

// Find by ID
final todo = await db.read(todoId);

// Find with limit and offset
final recentTodos = await db.findByType('todos', limit: 10, offset: 0);
```

### Advanced Queries
```dart
// Find by tags
final flutterArticles = await db.findByTag('flutter');

// Count documents by type
final todoCount = await db.countByType('todos');

// Get all document types
final types = await db.getTypes();

// Clear all documents of a type
final deletedCount = await db.clearType('old_logs');
```

### Reactive Queries
```dart
// Watch all documents of a type
Stream<List<Map<String, dynamic>>> todoStream = db.watchByType('todos');
```

## ğŸ“ CRUD Operations

### Create
```dart
// Basic creation
final id = await db.create('todos', {
  'title': 'New Task',
  'completed': false,
});

// With tags
final id = await db.create('projects', {
  'name': 'Flutter App',
  'description': 'My awesome app',
  'status': 'active',
}, tags: ['work', 'flutter']);
```

### Read
```dart
// Single document
final doc = await db.read(todoId);
if (doc != null) {
  print('Title: ${doc['title']}');
  print('Type: ${doc['_type']}');
  print('Created: ${doc['_createdAt']}');
}
```

### Update
```dart
// Partial update
await db.update(todoId, {
  'completed': true,
  'completedAt': DateTime.now().toIso8601String(),
});

// Update with tags
await db.update(todoId, {
  'priority': 'high',
}, tags: ['urgent', 'work']);
```

### Delete
```dart
// Soft delete (marks as deleted, keeps data)
await db.delete(todoId);

// Hard delete (permanently removes)
await db.hardDelete(todoId);
```

## â˜ï¸ Real-time Synchronization

### Automatic Cloud Sync
InstantDB automatically handles cloud synchronization:
```dart
// Initialize with InstantDB (automatic from environment)
await db.initialize(
  appId: dotenv.env['INSTANTDB_APP_ID'],
  enableSync: true,
);
```

### Real-time Updates
```dart
// All changes sync automatically across clients
final id = await db.create('todos', {
  'title': 'New Task',
  'completed': false,
});

// Changes are immediately visible to all connected clients
// No manual sync operations needed!
```

### Built-in Conflict Resolution
InstantDB uses operational transforms for automatic conflict resolution:
- **Optimistic updates** - Changes appear immediately in UI
- **Automatic conflict resolution** - No manual intervention needed
- **Real-time synchronization** - All clients stay in sync
- **Offline-first** - Works seamlessly when disconnected

### Connection Monitoring
```dart
// Watch connection status with Signals
Watch((context) {
  final status = db.connectionStatus.value;
  
  return Row(
    children: [
      Icon(
        status == DatabaseConnectionStatus.connected 
          ? Icons.cloud_done 
          : Icons.cloud_off,
        color: status == DatabaseConnectionStatus.connected
          ? Colors.green
          : Colors.grey,
      ),
      Text('InstantDB: ${status.toString().split('.').last}'),
    ],
  );
});
```

## ğŸš€ Performance & Optimization

### InstantDB Features
InstantDB provides real-time NoSQL storage:
- **Real-time sync** - Changes propagate instantly to all connected clients
- **Offline-first** - Works seamlessly without internet connection  
- **Local caching** - Fast local queries with automatic cloud sync
- **Zero code generation** - No build_runner or generated files needed
- **Built-in authentication** - Magic links and social auth included
- **Schemaless** - No database migrations or schema changes needed

### Database Statistics
```dart
// Get detailed statistics
final stats = await db.getStats();
print('Total documents: ${stats.totalDocuments}');
print('Active documents: ${stats.activeDocuments}');
print('Deleted documents: ${stats.deletedDocuments}');
print('Document types: ${stats.documentTypes}');
print('Database size: ${stats.databaseSizeMB}MB');
```

## ğŸ§ª Testing

### Test Database
```dart
void main() {
  late DatabaseService db;
  
  setUp(() async {
    TestWidgetsFlutterBinding.ensureInitialized();
    db = DatabaseService.instance;
    await db.initialize();
  });
  
  test('should create and retrieve document', () async {
    final id = await db.create('todos', {
      'title': 'Test Todo',
      'completed': false,
    });
    
    final doc = await db.read(id);
    expect(doc, isNotNull);
    expect(doc!['title'], equals('Test Todo'));
    expect(doc['completed'], equals(false));
  });
  
  tearDown(() async {
    await db.close();
  });
}
```

## ğŸ”§ Configuration

### Initialization Options
```dart
await db.initialize(
  // Automatic configuration from .env file
  appId: dotenv.env['INSTANTDB_APP_ID'],
  enableSync: dotenv.env['INSTANTDB_ENABLE_SYNC'] != 'false',
  verboseLogging: dotenv.env['INSTANTDB_VERBOSE_LOGGING'] == 'true',
);
```

### Connection Status
```dart
// Monitor database connection status with Signals
Watch((context) {
  final status = db.connectionStatus.value;
  
  return switch (status) {
    DatabaseConnectionStatus.connected => Icon(Icons.check_circle, color: Colors.green),
    DatabaseConnectionStatus.connecting => CircularProgressIndicator(),
    DatabaseConnectionStatus.error => Icon(Icons.error, color: Colors.red),
    DatabaseConnectionStatus.disconnected => Icon(Icons.offline_bolt),
  };
});
```

## ğŸ“Š Monitoring & Debugging

### Service Inspector Integration
The Database Service integrates with the Service Inspector for real-time monitoring:

- **Document counts** by type
- **Sync status** and last sync time
- **Connection status** monitoring
- **Error logs** and debugging information
- **Interactive testing** - create, update, delete documents

### Real-time Signals
The DatabaseService uses Signals for reactive status updates:
```dart
// Connection status
final connectionStatus = signal<DatabaseConnectionStatus>(DatabaseConnectionStatus.disconnected);

// Cloud sync status  
final cloudSyncStatus = signal<CloudSyncStatus>(CloudSyncStatus.disabled);

// Last sync timestamp
final lastSyncTime = signal<DateTime?>(null);

// Real-time updates counter
final realtimeUpdates = signal<int>(0);
```

## ğŸ¯ Key Advantages of InstantDB

### Real-time Database
Unlike traditional databases, InstantDB provides **real-time synchronization**:
- âŒ No manual polling for updates
- âŒ No complex sync logic to implement
- âŒ No schema migrations to manage
- âœ… Automatic real-time updates across all clients
- âœ… Offline-first with automatic sync when reconnected
- âœ… Built-in authentication and permissions

### Document Structure
```dart
// InstantDB approach (schemaless, no setup required)
final doc = await db.create('todos', {
  'title': 'My Todo',
  'completed': false,
  'tags': ['work', 'urgent'],
  'metadata': {
    'priority': 'high',
    'assignee': 'user123'
  }
});

// Query in real-time
db.watchByType('todos').listen((docs) {
  // UI automatically updates when data changes
  // on any connected client!
});
```

## ğŸ”— Related Documentation

- **[Services Overview](README.md)** - Overview of all services
- **[Architecture](../architecture.md)** - How Database Service fits in the overall architecture
- **[Migration Guide](../migration-guide.md)** - Migrating to InstantDB

The Database Service provides a powerful, flexible foundation for your app's data needs. Start with simple local storage and gradually add cloud sync and advanced features as your app grows! ğŸ—„ï¸

---

## Framework Specification

*Comprehensive technical specification and design document*

# Flutter Application Shell Framework Specification

## Overview

The Flutter Application Shell is a comprehensive framework designed to eliminate boilerplate code and accelerate Flutter application development. It provides a standardized foundation with pre-configured services, responsive navigation, multi-UI system support, and state management through signals.

## âœ¨ Key Features at a Glance

### ğŸš€ **Zero-Config Development**
- **Instant App Setup**: One function call creates a fully functional app with navigation, theming, and services
- **Auto-Generated Settings Page**: Professional settings UI that adapts to your chosen design system
- **Responsive Navigation**: Automatically switches between bottom tabs, side rail, and full sidebar based on screen size
- **Smart Routing**: GoRouter integration with deep linking, authentication guards, and nested routes

### ğŸ¨ **Multi-UI System Support**
- **Three Design Systems**: Seamlessly switch between Material Design, Cupertino (iOS), and ForUI
- **Adaptive Components**: All UI components automatically match the selected design system
- **Theme Management**: Built-in light/dark mode with user preferences and system detection
- **Consistent Experience**: Same codebase, native feel on every platform

### ğŸ”§ **Comprehensive Service Layer**
- **Dependency Injection**: GetIt-based service container with automatic registration
- **Signal-First State Management**: Reactive state with Flutter signals integration
- **Database Ready**: NoSQL database service with migrations and CRUD operations
- **Preferences Management**: Type-safe SharedPreferences wrapper with reactive updates
- **Advanced Logging**: Multi-level logging with user-configurable filtering and remote integration

### ğŸ“± **Intelligent Layout Engine**
- **Adaptive Navigation**: 
  - Mobile: Bottom tabs (â‰¤5) or drawer navigation (>5)
  - Tablet: Side navigation rail with collapsible labels
  - Desktop: Full sidebar with hamburger toggle
- **Wizard/Stepper Interface**: Linear step-by-step navigation for guided workflows
- **Responsive Breakpoints**: Automatic layout switching at 600dp, 840dp, and 1200dp
- **Master-Detail Support**: Built-in patterns for complex layouts
- **Collapsible Sidebar**: Manual and automatic sidebar collapse with smooth animations

### âš™ï¸ **Developer Experience**
- **Extensible Settings**: Add custom settings sections with validation and constraints
- **Debug Tools**: Development-only settings for logging, performance monitoring, and feature flags
- **Hot Reload Support**: Services maintain state during development
- **Type Safety**: Strongly typed APIs throughout the framework
- **Migration Tools**: Utilities for upgrading existing apps to use the shell

### â˜ï¸ **Cloud Integration Ready**
- **InstantDB Integration**: Zero-config authentication and database setup with real-time sync
- **Magic Link Authentication**: Passwordless authentication with biometric support
- **Real-time Sync**: Automatic data synchronization across all connected clients
- **Offline-First**: Local database with seamless cloud sync when connectivity is available

### ğŸ” **Production Ready**
- **Authentication Integration**: Built-in auth service with biometric support
- **Network Layer**: HTTP client with interceptors and offline handling
- **Caching System**: Multi-level caching with automatic invalidation
- **Analytics Ready**: Event tracking and performance monitoring hooks
- **Error Handling**: Comprehensive error boundaries and crash reporting

## Core Philosophy

- **Speed over Size**: Prioritize development velocity over application bundle size
- **Service-Oriented Architecture**: All functionality exposed through injectable services
- **Adaptive by Default**: Responsive layouts and navigation that adapt to screen size and platform
- **Signals-First**: State management built around Flutter signals
- **Zero Configuration**: Works out of the box with sensible defaults, configurable when needed

## Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   App Routes    â”‚  â”‚   App Pages     â”‚  â”‚  App Logic   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Application Shell                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Navigation     â”‚  â”‚  Layout Engine  â”‚  â”‚  UI Systems  â”‚ â”‚
â”‚  â”‚  Service        â”‚  â”‚                 â”‚  â”‚  Manager     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Core Services                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Database    â”‚  â”‚ Preferences  â”‚  â”‚  Dependency Injectionâ”‚ â”‚
â”‚  â”‚  Service     â”‚  â”‚ Service      â”‚  â”‚  Container (GetIt)   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Core Components

### 1. Application Shell Entry Point

```dart
class AppShell {
  static Future<Widget> initialize({
    required List<AppRoute> routes,
    required List<ShellPage> rootPages,
    AppShellConfig? config,
    List<ServiceRegistration>? additionalServices,
  }) async {
    // Initialize all core services
    // Set up dependency injection
    // Configure navigation
    // Return the root widget
  }
}
```

### 2. Service Layer

#### Core Services (Always Available)

**NavigationService**
- GoRouter integration and configuration
- Programmatic navigation
- Route state management
- Deep linking support

**PreferencesService**
- SharedPreferences wrapper
- Type-safe preference access
- Reactive preferences with signals
- Migration support

**DatabaseService**
- NoSQL database abstraction (using client-sdk-flutter)
- CRUD operations
- Schema management
- Migration utilities

**UISystemService**
- Dynamic UI system switching (Cupertino/Material/ForUI)
- Theme management
- Platform-aware defaults

**LayoutService**
- Responsive layout decisions
- Screen size detection
- Navigation style selection (bottom tabs vs sidebar)

**SignalService**
- Global signal management
- Cross-service communication
- State persistence integration

#### Optional Services (Configurable)

**AuthenticationService**
- User authentication flows
- Token management
- Biometric authentication

**NetworkService**
- HTTP client configuration
- Request/response interceptors
- Offline handling

**SettingsService**
- Auto-generated settings page
- Multi-UI system adaptive interface
- Extensible settings sections
- Built-in core settings (theme, onboarding, logging)
- Type-safe settings definitions
- Settings validation and constraints

**LoggingService**
- Structured logging with multiple levels (trace, debug, info, warn, error, fatal)
- Remote logging integration (configurable endpoints)
- Debug/release configurations
- Filtering and search capabilities
- Performance logging and metrics
- User-configurable log levels and filtering
- Log file management and rotation
- Crash reporting integration

**AnalyticsService**
- Event tracking
- User behavior analytics
- Performance monitoring

**NotificationService**
- Push notifications
- Local notifications
- Permission management

**LocalizationService**
- Multi-language support with automatic locale detection
- Adaptive text direction (LTR/RTL)
- Date, time, and number formatting
- Dynamic language switching with app restart

**KeyboardShortcutService**
- Platform-aware keyboard shortcuts
- Customizable shortcut registration
- Accessibility compliance
- Developer shortcuts (debug panel, settings, etc.)

**OnboardingService**
- Configurable onboarding flows
- Progress tracking and persistence
- Skip/replay functionality
- Adaptive UI for different screen sizes

**PermissionService**
- Unified permission management
- Graceful permission degradation
- User-friendly permission explanations
- Permission status monitoring

**BiometricService**
- Fingerprint and face authentication
- Platform-specific implementations
- Fallback to PIN/password
- Security level detection

**UpdateService**
- In-app update notifications
- Version compatibility checking
- Force update capabilities
- Release notes integration

**FeatureFlagService**
- Runtime feature toggling
- A/B testing support
- Remote configuration
- User segment targeting

**AccessibilityService**
- Screen reader optimization
- High contrast themes
- Font size scaling
- Focus management

**ErrorBoundaryService**
- Global error catching and reporting
- User-friendly error messages
- Crash analytics integration
- Recovery mechanisms

**InstantDBService** (Included)
- Complete InstantDB integration with authentication
- Real-time NoSQL database with automatic sync
- Auto-generated authentication pages
- Realtime data synchronization
- Row-level security integration
- File storage and management

**WizardNavigationService**
- Step-by-step navigation system
- Progress tracking and persistence
- Dynamic step generation
- Validation per step
- Branching logic support
- Integration with standard navigation

### 3. Navigation System

#### Route Definition

```dart
class AppRoute {
  final String path;
  final Widget Function(BuildContext context, GoRouterState state) builder;
  final List<AppRoute>? children;
  final bool requiresAuth;
  final Map<String, dynamic>? metadata;
  
  const AppRoute({
    required this.path,
    required this.builder,
    this.children,
    this.requiresAuth = false,
    this.metadata,
  });
}
```

#### Shell Page Definition

```dart
class ShellPage {
  final String label;
  final IconData icon;
  final String route;
  final bool showInNavigation;
  final int? order;
  final ShellPageVisibility visibility;
  
  const ShellPage({
    required this.label,
    required this.icon,
    required this.route,
    this.showInNavigation = true,
    this.order,
    this.visibility = ShellPageVisibility.always,
  });
}

enum ShellPageVisibility {
  always,
  mobileOnly,
  desktopOnly,
  authenticated,
  unauthenticated,
}
```

### 4. Responsive Layout Engine

#### Adaptive Navigation Rules

**Mobile Portrait (< 600dp width)**
- Bottom tab bar (up to 5 tabs)
- Drawer navigation (> 5 tabs)
- Stack-based navigation

**Mobile Landscape (600-840dp width)**
- Side navigation rail with collapsible labels
- Hamburger menu to toggle rail expansion
- Persistent bottom sheet support
- Smooth expand/collapse animations

**Tablet (840-1200dp width)**
- Side navigation rail with labels (always expanded by default)
- Optional hamburger menu for manual collapse
- Master-detail layouts with adaptive content
- Multi-pane support with responsive breakpoints

**Desktop (> 1200dp width)**
- Full sidebar navigation (expanded by default)
- Hamburger menu in top-left corner for manual toggle
- Multi-window support with consistent navigation state
- Keyboard shortcuts (Ctrl+\\ or Cmd+\\ to toggle sidebar)
- Persistent sidebar state across app sessions

#### Layout Configuration

```dart
class LayoutConfig {
  final int maxBottomTabs;
  final bool enableDrawer;
  final bool enableRail;
  final bool enableSidebar;
  final bool enableSidebarToggle;
  final bool persistSidebarState;
  final EdgeInsets contentPadding;
  final double? maxContentWidth;
  final Duration sidebarAnimationDuration;
  final double collapsedSidebarWidth;
  final double expandedSidebarWidth;
  
  const LayoutConfig({
    this.maxBottomTabs = 5,
    this.enableDrawer = true,
    this.enableRail = true,
    this.enableSidebar = true,
    this.enableSidebarToggle = true,
    this.persistSidebarState = true,
    this.contentPadding = const EdgeInsets.all(16.0),
    this.maxContentWidth,
    this.sidebarAnimationDuration = const Duration(milliseconds: 250),
    this.collapsedSidebarWidth = 72.0,
    this.expandedSidebarWidth = 256.0,
  });
}
```

#### Sidebar Management Service

```dart
class SidebarService {
  final Signal<bool> isExpanded = Signal(true);
  final Signal<bool> isPinned = Signal(false);
  final Signal<SidebarMode> currentMode = Signal(SidebarMode.auto);
  
  void toggleSidebar() { ... }
  void expandSidebar() { ... }
  void collapseSidebar() { ... }
  void pinSidebar(bool pinned) { ... }
  void setSidebarMode(SidebarMode mode) { ... }
  
  // Auto-collapse on mobile when content is accessed
  void handleContentInteraction() { ... }
  
  // Restore sidebar state from preferences
  Future<void> restoreState() { ... }
  Future<void> persistState() { ... }
}

enum SidebarMode {
  auto,      // Responsive behavior
  alwaysExpanded,
  alwaysCollapsed,
  manual,    // User controls via hamburger only
}
```

### 5. UI System Management

#### UI System Interface

```dart
abstract class UISystem {
  ThemeData get lightTheme;
  ThemeData get darkTheme;
  Widget buildButton({required VoidCallback onPressed, required Widget child});
  Widget buildCard({required Widget child});
  Widget buildTextField({required String label});
  // ... other UI components
}

class CupertinoUISystem implements UISystem { ... }
class MaterialUISystem implements UISystem { ... }
class ForUISystem implements UISystem { ... }
```

#### Theme Integration

```dart
class UISystemService {
  Signal<UISystemType> currentSystem = Signal(UISystemType.material);
  Signal<ThemeMode> themeMode = Signal(ThemeMode.system);
  
  void switchUISystem(UISystemType system) { ... }
  ThemeData getCurrentTheme(Brightness brightness) { ... }
}
```

### 7. Settings System

#### Automatic Settings Page Generation

The shell provides a fully functional settings page that adapts to the current UI system and can be extended with custom sections.

#### Core Settings (Built-in)

```dart
class CoreSettings {
  // Theme Management
  static final themeMode = SettingDefinition<ThemeMode>(
    key: 'theme_mode',
    defaultValue: ThemeMode.system,
    title: 'Theme',
    description: 'Choose your preferred theme',
    section: 'appearance',
  );
  
  static final uiSystem = SettingDefinition<UISystemType>(
    key: 'ui_system',
    defaultValue: UISystemType.material,
    title: 'UI Style',
    description: 'Select the interface style',
    section: 'appearance',
  );
  
  // Onboarding
  static final hasSeenOnboarding = SettingDefinition<bool>(
    key: 'has_seen_onboarding',
    defaultValue: false,
    title: 'Onboarding Completed',
    description: 'Whether the user has completed onboarding',
    section: 'system',
    hidden: true, // Not shown in UI
  );
  
  static final resetOnboarding = SettingAction(
    key: 'reset_onboarding',
    title: 'Reset Onboarding',
    description: 'Show onboarding screens again',
    section: 'system',
    action: () => GetIt.I<PreferencesService>().setBool('has_seen_onboarding', false),
  );
  
  // Logging
  static final enableDebugLogging = SettingDefinition<bool>(
    key: 'enable_debug_logging',
    defaultValue: false,
    title: 'Debug Logging',
    description: 'Enable detailed debug logs',
    section: 'developer',
    developmentOnly: true,
  );
  
  static final logLevel = SettingDefinition<LogLevel>(
    key: 'log_level',
    defaultValue: LogLevel.info,
    title: 'Log Level',
    description: 'Minimum log level to display',
    section: 'developer',
    developmentOnly: true,
  );
  
  static final logFilterPattern = SettingDefinition<String>(
    key: 'log_filter_pattern',
    defaultValue: '',
    title: 'Log Filter',
    description: 'Filter logs by pattern (regex supported)',
    section: 'developer',
    developmentOnly: true,
  );
}
```

#### Custom Settings Definition

```dart
abstract class SettingDefinition<T> {
  final String key;
  final T defaultValue;
  final String title;
  final String? description;
  final String section;
  final bool hidden;
  final bool developmentOnly;
  final List<SettingConstraint<T>>? constraints;
  final List<T>? allowedValues;
  final Widget Function(BuildContext, SettingDefinition<T>)? customBuilder;
  
  const SettingDefinition({
    required this.key,
    required this.defaultValue,
    required this.title,
    this.description,
    required this.section,
    this.hidden = false,
    this.developmentOnly = false,
    this.constraints,
    this.allowedValues,
    this.customBuilder,
  });
}

class SettingAction {
  final String key;
  final String title;
  final String? description;
  final String section;
  final bool developmentOnly;
  final VoidCallback action;
  final Widget? icon;
  
  const SettingAction({
    required this.key,
    required this.title,
    this.description,
    required this.section,
    this.developmentOnly = false,
    required this.action,
    this.icon,
  });
}
```

#### Settings Service Interface

```dart
class SettingsService {
  final List<SettingDefinition> _definitions = [];
  final List<SettingAction> _actions = [];
  final Map<String, List<SettingDefinition>> _sections = {};
  
  // Register custom settings
  void registerSetting<T>(SettingDefinition<T> setting) { ... }
  void registerAction(SettingAction action) { ... }
  void registerSection(String key, String title, {String? description, int? order}) { ... }
  
  // Get setting values
  T getSetting<T>(String key) { ... }
  void setSetting<T>(String key, T value) { ... }
  
  // Settings page generation
  Widget buildSettingsPage({
    List<String>? visibleSections,
    bool showDeveloperSettings = false,
  }) { ... }
  
  // Settings sections
  Map<String, List<SettingDefinition>> getSettingsSections() { ... }
  Widget buildSettingsSection(String sectionKey) { ... }
}
```

#### Built-in Settings Sections

**Appearance Section**
- Theme mode (Light/Dark/System)
- UI system selection (Material/Cupertino/ForUI)
- Font size adjustment
- Color scheme preferences

**System Section**
- Reset onboarding
- Clear cache
- Export/import settings
- App version info

**Developer Section** (Debug builds only)
- Debug logging toggle
- Log level selection
- Log filtering
- Performance monitoring
- Feature flags

#### Usage in Applications

```dart
// Register custom settings
void setupAppSettings() {
  final settings = GetIt.I<SettingsService>();
  
  // Register a custom section
  settings.registerSection(
    'notifications', 
    'Notifications',
    description: 'Manage notification preferences',
    order: 1,
  );
  
  // Register custom settings
  settings.registerSetting(SettingDefinition<bool>(
    key: 'enable_push_notifications',
    defaultValue: true,
    title: 'Push Notifications',
    description: 'Receive push notifications',
    section: 'notifications',
  ));
  
  settings.registerSetting(SettingDefinition<int>(
    key: 'notification_frequency',
    defaultValue: 60,
    title: 'Check Frequency (minutes)',
    description: 'How often to check for new notifications',
    section: 'notifications',
    constraints: [
      MinValueConstraint(1),
      MaxValueConstraint(1440),
    ],
  ));
  
  // Register custom action
  settings.registerAction(SettingAction(
    key: 'test_notification',
    title: 'Send Test Notification',
    description: 'Send a test notification now',
    section: 'notifications',
    action: () => _sendTestNotification(),
    icon: Icon(Icons.notification_add),
  ));
}

// Use in navigation
ShellPage(
  label: 'Settings',
  icon: Icons.settings,
  route: '/settings',
), // Automatically uses SettingsService.buildSettingsPage()
```

#### Adaptive UI Rendering

The settings page automatically adapts to the current UI system:

**Material Design**
- Uses Material switches, sliders, and list tiles
- Material color schemes
- Material typography

**Cupertino**
- Uses Cupertino switches and segmented controls
- iOS-style navigation
- Cupertino typography

**ForUI**
- Uses ForUI components
- Custom styling and interactions
- ForUI design system compliance

#### Settings Constraints and Validation

```dart
abstract class SettingConstraint<T> {
  bool validate(T value);
  String get errorMessage;
}

class MinValueConstraint<T extends num> extends SettingConstraint<T> {
  final T minValue;
  MinValueConstraint(this.minValue);
  
  @override
  bool validate(T value) => value >= minValue;
  
  @override
  String get errorMessage => 'Value must be at least $minValue';
}

class MaxLengthConstraint extends SettingConstraint<String> {
  final int maxLength;
  MaxLengthConstraint(this.maxLength);
  
  @override
  bool validate(String value) => value.length <= maxLength;
  
  @override
  String get errorMessage => 'Text must be no more than $maxLength characters';
}
```

#### Global Signal Management

```dart
class SignalService {
  final Map<String, Signal> _globalSignals = {};
  
  T createGlobalSignal<T>(String key, T initialValue) { ... }
  T? getGlobalSignal<T>(String key) { ... }
  void persistSignal(String key) { ... }
  void restoreSignal(String key) { ... }
}
```

#### Service Communication

```dart
mixin SignalAware {
  List<Signal> get watchedSignals;
  void onSignalChanged(Signal signal, dynamic oldValue, dynamic newValue);
}
```

## Configuration System

### AppShellConfig

```dart
class AppShellConfig {
  final String appName;
  final String appVersion;
  final LayoutConfig layout;
  final DatabaseConfig database;
  final NavigationConfig navigation;
  final UIConfig ui;
  final List<ServiceConfig> services;
  
  const AppShellConfig({
    required this.appName,
    required this.appVersion,
    this.layout = const LayoutConfig(),
    this.database = const DatabaseConfig(),
    this.navigation = const NavigationConfig(),
    this.ui = const UIConfig(),
    this.services = const [],
  });
}
```

### Service Registration

```dart
abstract class ServiceRegistration {
  String get name;
  Future<void> register(GetIt container);
  List<String> get dependencies;
  ServicePriority get priority;
}

enum ServicePriority {
  critical,  // Must be available before app starts
  high,      // Should be available early
  normal,    // Can be lazy-loaded
  background // Can be initialized in background
}
```

## Usage Examples

### Basic App Setup

```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  final app = await AppShell.initialize(
    routes: [
      AppRoute(
        path: '/',
        builder: (context, state) => const HomePage(),
      ),
      AppRoute(
        path: '/settings',
        builder: (context, state) => const SettingsPage(),
      ),
    ],
    rootPages: [
      ShellPage(
        label: 'Home',
        icon: Icons.home,
        route: '/',
      ),
      ShellPage(
        label: 'Settings',
        icon: Icons.settings,
        route: '/settings',
      ),
    ],
  );
  
  runApp(app);
}
```

#### Usage with InstantDB and Wizard

```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  final app = await AppShell.initialize(
    config: AppShellConfig(
      appName: 'My InstantDB App',
      appVersion: '1.0.0',
      // InstantDB is automatically configured from environment variables
      // Just add INSTANTDB_APP_ID to your .env file
      // Enable wizard mode for onboarding
      wizard: WizardConfig(
        mode: NavigationMode.hybrid,
        steps: [
          WizardStep(
            id: 'welcome',
            title: 'Welcome',
            builder: (context, controller) => WelcomeScreen(),
          ),
          WizardStep(
            id: 'profile',
            title: 'Create Profile',
            builder: (context, controller) => ProfileSetupScreen(),
            validator: (controller) async => 
              controller.getStepData('profile')?['name']?.isNotEmpty ?? false,
          ),
          WizardStep(
            id: 'preferences',
            title: 'Preferences',
            builder: (context, controller) => PreferencesScreen(),
            optional: true,
          ),
        ],
        onComplete: () {
          // Mark onboarding complete and switch to standard navigation
          GetIt.I<PreferencesService>().setBool('onboarding_complete', true);
        },
      ),
    ),
    routes: MyAppRoutes.all,
    rootPages: MyAppPages.main,
  );
  
  runApp(app);
}
```

### Service Usage with Enhanced Features

```dart
class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final nav = GetIt.I<NavigationService>();
    final instantdb = GetIt.I<DatabaseService>();
    final wizard = GetIt.I<WizardNavigationService>();
    final settings = GetIt.I<SettingsService>();
    final logger = GetIt.I<LoggingService>();
    
    return Scaffold(
      body: Column(
        children: [
          // Show user info if authenticated
          SignalBuilder(
            signal: auth.currentUser,
            builder: (context, user) => user != null 
              ? Text('Welcome, ${user.email}')
              : ElevatedButton(
                  onPressed: () => nav.push('/auth/signin'),
                  child: Text('Sign In'),
                ),
          ),
          
          // Show wizard progress if in wizard mode
          SignalBuilder(
            signal: settings.getSetting<bool>('enable_wizard_mode'),
            builder: (context, isWizardMode) => isWizardMode
              ? LinearProgressIndicator(value: wizard.progress)
              : SizedBox.shrink(),
          ),
          
          // Navigation controls
          if (wizard.currentStepIndex.value > 0)
            ElevatedButton(
              onPressed: wizard.previousStep,
              child: Text('Previous'),
            ),
          ElevatedButton(
            onPressed: wizard.nextStep,
            child: Text('Next'),
          ),
        ],
      ),
    );
  }
}
```

## Migration Strategy

### Existing App Migration

1. **Assessment Phase**
   - Analyze current app structure
   - Identify services that can be migrated
   - Plan migration order

2. **Gradual Migration**
   - Start with navigation service
   - Move to preferences and database
   - Migrate UI components last

3. **Testing & Validation**
   - Comprehensive testing at each step
   - Performance benchmarking
   - User acceptance testing

### Version Management

- Semantic versioning for the shell
- Breaking change documentation
- Migration guides for major versions
- Backward compatibility where possible

## Development Roadmap

### Phase 1: Core Foundation
- [ ] Basic service container setup
- [ ] Navigation service implementation
- [ ] Preferences service implementation
- [ ] Basic responsive layout

### Phase 2: Enhanced Features
- [ ] Database service integration
- [ ] UI system management
- [ ] Signal service implementation
- [ ] Advanced routing features
- [ ] Logging service with filtering
- [ ] Auto-generated settings page
- [ ] Settings constraints and validation
- [ ] Wizard/stepper navigation system
- [ ] InstantDB authentication integration

### Phase 3: Extended Services
- [ ] Full InstantDB integration (database, storage, realtime)
- [ ] Comprehensive notification system (in-app, push, local)
- [ ] Authentication service with biometric support
- [ ] Network service with interceptors
- [ ] Caching service with multi-level storage
- [ ] Localization service with RTL support
- [ ] Keyboard shortcut service
- [ ] Onboarding service with wizard integration

### Phase 4: Advanced Services
- [ ] Permission management service
- [ ] Update service with in-app notifications
- [ ] Feature flag service with A/B testing
- [ ] Accessibility service with screen reader optimization
- [ ] Error boundary service with crash reporting
- [ ] Sync service with offline-first data handling
- [ ] Performance monitoring service

### Phase 4: Developer Experience
- [ ] Code generation tools for settings and routes
- [ ] CLI for project scaffolding and service generation
- [ ] Hot reload support for service configuration
- [ ] Comprehensive documentation with interactive examples
- [ ] Example applications showcasing different patterns
- [ ] VS Code extension with snippets and tools
- [ ] Debug panel with service inspection
- [ ] Performance profiling tools

### Phase 5: Advanced Features
- [ ] Plugin architecture for third-party extensions
- [ ] Multi-app support with shared services
- [ ] Cloud integration templates
- [ ] Advanced analytics and telemetry
- [ ] Automated testing utilities and mocks
- [ ] CI/CD integration templates
- [ ] Enterprise features (SSO, compliance, audit logs)
- [ ] Custom design system support beyond the three core systems

## Additional Framework Enhancements

### ğŸ¨ **Advanced Theming & Customization**
- **Dynamic Theme Generation**: Create themes from user-uploaded images
- **Component Library**: Pre-built, customizable widgets that work across all UI systems
- **Design Token System**: Consistent spacing, typography, and color tokens
- **Theme Marketplace**: Downloadable community-created themes

### ğŸ”Œ **Plugin & Extension System**
- **Service Plugins**: Easy third-party service integration
- **Widget Extensions**: Custom UI components that integrate with the shell
- **Theme Plugins**: Custom UI systems beyond the core three
- **Workflow Plugins**: Custom automation and trigger systems

### ğŸ§ª **Developer Experience Tools**
- **Live Configuration Panel**: Real-time shell configuration changes during development
- **Service Inspector**: Debug panel showing service states and interactions
- **Performance Profiler**: Built-in performance monitoring and optimization suggestions
- **Code Generation CLI**: Generate boilerplate for new services and pages

### ğŸ“Š **Analytics & Monitoring**
- **Built-in Analytics**: User behavior tracking with privacy controls
- **Performance Metrics**: App performance monitoring and alerts
- **Error Tracking**: Comprehensive crash reporting and error analysis
- **Usage Statistics**: Service usage patterns and optimization insights

### ğŸŒ **Enterprise Features**
- **Single Sign-On (SSO)**: Enterprise authentication integration
- **Multi-tenant Support**: Multiple organizations in one app instance
- **Compliance Tools**: GDPR, HIPAA, SOX compliance utilities
- **Audit Logging**: Comprehensive audit trails for enterprise environments

### ğŸ¯ **Final Completeness Additions**

#### **FileService**
- **File management** with local and cloud storage
- **File preview** generation and caching
- **Upload progress** tracking with resumable uploads
- **File organization** with tagging and search
- **Automatic compression** and format optimization

#### **StateManagementService**
- **Global app state** management beyond signals
- **State persistence** and restoration
- **Undo/redo** functionality
- **State synchronization** across multiple app instances
- **Time-travel debugging** for development

#### **ConfigurationService**
- **Runtime configuration** changes without code deployment
- **A/B testing** configuration management
- **Feature flagging** with user segmentation
- **Remote configuration** with fallback to local defaults
- **Configuration versioning** and rollback capabilities
- **Hot Reload Service Configuration**: Change service settings without app restart during development
- **Interactive Documentation**: Live docs that update based on your app configuration
- **Service Dependency Visualizer**: Visual graph showing service relationships and dependencies
- **Configuration Validator**: Real-time validation of shell configuration with helpful error messages

### ğŸ› ï¸ **Developer Productivity Tools**
- **Hot Reload Service Configuration**: Change service settings without app restart during development
- **Interactive Documentation**: Live docs that update based on your app configuration
- **Service Dependency Visualizer**: Visual graph showing service relationships and dependencies
- **Configuration Validator**: Real-time validation of shell configuration with helpful error messages

### ğŸ“¦ **Package Management & Distribution**
- **Modular Architecture**: Core shell + optional service packages for smaller bundle sizes
- **Version Compatibility Matrix**: Clear compatibility between shell versions and service packages
- **Migration Assistant**: Automated migration tools for updating between shell versions
- **Package Templates**: Pre-configured package combinations for common app types

### ğŸš€ **Deployment & DevOps**
- **Environment Configuration**: Easy staging/production environment switching
- **Build Optimization**: Automatic dead code elimination and tree shaking for unused services
- **CI/CD Templates**: Pre-built GitHub Actions, GitLab CI templates for shell-based apps
- **Health Check Service**: Built-in app health monitoring and diagnostics

### ğŸ’¡ **Quick Start Enhancements**
- **Setup Wizard CLI**: Interactive command-line tool for initial project setup
- **Configuration Generator**: Web-based tool to generate shell configuration
- **Code Snippets Library**: VS Code/Android Studio extensions with shell-specific snippets
- **Error Recovery System**: Automatic error recovery and helpful debugging suggestions
- **Modular Architecture**: Core shell + optional service packages for smaller bundle sizes
- **Version Compatibility Matrix**: Clear compatibility between shell versions and service packages
- **Migration Assistant**: Automated migration tools for updating between shell versions
- **Package Templates**: Pre-configured package combinations for common app types

### ğŸš€ **Deployment & DevOps**
- **Environment Configuration**: Easy staging/production environment switching
- **Build Optimization**: Automatic dead code elimination and tree shaking for unused services
- **CI/CD Templates**: Pre-built GitHub Actions, GitLab CI templates for shell-based apps
- **Health Check Service**: Built-in app health monitoring and diagnostics

### ğŸ’¡ **Quick Start Enhancements**
- **Setup Wizard CLI**: Interactive command-line tool for initial project setup
- **Configuration Generator**: Web-based tool to generate shell configuration
- **Code Snippets Library**: VS Code/Android Studio extensions with shell-specific snippets
- **Error Recovery System**: Automatic error recovery and helpful debugging suggestions

## ğŸ¯ What Makes This Framework Special

### **The "5-Minute App" Promise**
```bash
# Install the CLI
flutter pub global activate flutter_app_shell_cli

# Create a new app
flutter_shell create my_awesome_app --template=productivity

# Configure (optional - has smart defaults)
cd my_awesome_app
flutter_shell config

# Run immediately - fully functional app with:
# âœ… Authentication, navigation, settings, themes, offline sync
flutter run
```

### **Zero-Config Production Ready**
- **InstantDB integration** works with just app ID + environment config
- **Authentication pages** auto-generated and routed
- **Settings page** automatically populated and styled
- **Responsive navigation** adapts to any screen size
- **Offline-first** data handling with intelligent sync
- **Push notifications** configured with platform defaults

### **Scales From Simple to Complex**
- **Start simple**: Basic CRUD app with authentication
- **Add complexity**: Real-time collaboration, advanced workflows
- **Enterprise ready**: SSO, compliance, audit logs, multi-tenant
- **Never rewrite**: Framework grows with your needs

### **Developer Happiness Focused**
- **Hot reload** for service configuration changes
- **Interactive debugging** with service inspector
- **Automatic error recovery** with helpful suggestions
- **Living documentation** that updates with your config
- **Zero boilerplate** for 90% of common features

To showcase the full capabilities of the Flutter Application Shell, we'll create **TaskFlow Pro** - a productivity application that demonstrates every feature of the framework.

### Application Overview

TaskFlow Pro is a comprehensive task and project management application that combines personal productivity with team collaboration. It demonstrates the shell's flexibility by starting as a simple task manager for new users and evolving into a powerful project management suite.

### Feature Showcase Matrix

| Shell Feature | TaskFlow Pro Implementation |
|---------------|----------------------------|
| **Wizard Navigation** | Onboarding flow: Welcome â†’ Profile Setup â†’ Workspace Creation â†’ Team Invitation â†’ Tutorial |
| **Multi-UI Systems** | Material (Android), Cupertino (iOS), ForUI (Custom branding for teams) |
| **Responsive Layout** | Mobile: Bottom tabs, Tablet: Side rail, Desktop: Full sidebar with project tree |
| **InstantDB Integration** | User authentication, real-time collaboration, cloud sync |
| **Settings System** | Theme, notifications, sync preferences, team settings, accessibility options |
| **Data Sync** | Offline task creation with cloud sync, conflict resolution for team edits |
| **Search Service** | Global search across tasks, projects, team members, comments |
| **Logging Service** | Activity logs, audit trails for team actions, debug logs for developers |
| **Keyboard Shortcuts** | Quick task creation (Ctrl+N), search (Ctrl+F), navigation shortcuts |
| **Biometric Auth** | Secure app access, team workspace protection |
| **Feature Flags** | Beta features, team-specific functionality, A/B testing |
| **Localization** | Support for 10+ languages with RTL support |
| **Accessibility** | Screen reader support, high contrast themes, keyboard navigation |
| **Export/Import** | Project exports, data backup, team migration tools |
| **Workflows** | Automated task assignments, deadline reminders, status updates |
| **Notification System** | In-app notifications, push notifications, reminder system, team mentions |

### App Structure and Navigation

#### Standard Navigation Mode
```
ğŸ“± Mobile Layout:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TaskFlow Pro    ğŸ” âš™ï¸   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                         â”‚
â”‚   Main Content Area     â”‚
â”‚                         â”‚
â”‚                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“‹ ğŸ·ï¸ ğŸ‘¥ ğŸ“Š ğŸ“        â”‚
â”‚Tasks Tags Team Stats Moreâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ–¥ï¸ Desktop Layout:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ğŸ“‹ Tasks   â”‚ Task Details        â”‚
â”‚ğŸ·ï¸ Tags    â”‚                     â”‚
â”‚ğŸ‘¥ Team    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ğŸ“Š Stats   â”‚ â”‚ Task Title      â”‚ â”‚
â”‚ğŸ“ Projectsâ”‚ â”‚ Description...  â”‚ â”‚
â”‚âš™ï¸ Settingsâ”‚ â”‚ Due: Tomorrow   â”‚ â”‚
â”‚           â”‚ â”‚ Assigned: @me   â”‚ â”‚
â”‚           â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Wizard Mode (New Users)
```
Step 1: Welcome
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Welcome to TaskFlow!   â”‚
â”‚                         â”‚
â”‚ â—‹â”€â”€â”€â”€â—‹â”€â”€â”€â”€â—‹â”€â”€â”€â”€â—‹â”€â”€â”€â”€â—‹   â”‚ Progress
â”‚                         â”‚
â”‚ Get organized and boost â”‚
â”‚ your productivity with  â”‚
â”‚ powerful task managementâ”‚
â”‚                         â”‚
â”‚           [Next] â”€â”€â”€â”€â–¶  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: Profile Setup
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Create Your Profile   â”‚
â”‚                         â”‚
â”‚ â—â”€â”€â”€â”€â—‹â”€â”€â”€â”€â—‹â”€â”€â”€â”€â—‹â”€â”€â”€â”€â—‹   â”‚
â”‚                         â”‚
â”‚ Name: [John Doe       ] â”‚
â”‚ Email: [john@email.com] â”‚
â”‚ Role: [Developer   â–¼]   â”‚
â”‚ Avatar: [ğŸ“· Upload]     â”‚
â”‚                         â”‚
â”‚ [â—€ Back]      [Next] â–¶  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Detailed Feature Implementations

#### 1. Onboarding Wizard Journey
```dart
// Example wizard configuration in TaskFlow Pro
WizardConfig(
  mode: NavigationMode.hybrid,
  steps: [
    WizardStep(
      id: 'welcome',
      title: 'Welcome to TaskFlow Pro',
      icon: Icons.waving_hand,
      builder: (context, controller) => WelcomeScreen(),
    ),
    WizardStep(
      id: 'profile',
      title: 'Create Your Profile',
      icon: Icons.person,
      builder: (context, controller) => ProfileSetupScreen(),
      validator: (controller) async {
        final data = controller.getStepData('profile');
        return data?['name']?.isNotEmpty == true;
      },
    ),
    WizardStep(
      id: 'workspace',
      title: 'Set Up Workspace',
      icon: Icons.business,
      builder: (context, controller) => WorkspaceSetupScreen(),
      showIf: WizardStepCondition(
        dependentStepId: 'profile',
        customCondition: (data) => data['accountType'] == 'team',
      ),
    ),
    WizardStep(
      id: 'tutorial',
      title: 'Quick Tutorial',
      icon: Icons.school,
      optional: true,
      builder: (context, controller) => InteractiveTutorialScreen(),
    ),
  ],
)
```

#### 2. Multi-UI System Demonstration
- **Material Design**: Default Android experience with Material 3 components
- **Cupertino**: iOS-native feel with Cupertino widgets
- **ForUI (Custom)**: Branded experience for enterprise teams with custom color schemes

#### 3. Comprehensive Settings Panel
```dart
// Custom settings sections for TaskFlow Pro
void setupTaskFlowSettings() {
  final settings = GetIt.I<SettingsService>();
  
  // Productivity section
  settings.registerSection('productivity', 'Productivity');
  settings.registerSetting(SettingDefinition<Duration>(
    key: 'pomodoro_duration',
    defaultValue: Duration(minutes: 25),
    title: 'Pomodoro Timer Duration',
    section: 'productivity',
  ));
  
  // Team collaboration section
  settings.registerSection('collaboration', 'Team Collaboration');
  settings.registerSetting(SettingDefinition<bool>(
    key: 'real_time_notifications',
    defaultValue: true,
    title: 'Real-time Notifications',
    section: 'collaboration',
  ));
  
  // Data & Sync section
  settings.registerSection('sync', 'Data & Sync');
  settings.registerSetting(SettingDefinition<SyncFrequency>(
    key: 'sync_frequency',
    defaultValue: SyncFrequency.every5Minutes,
    title: 'Sync Frequency',
    section: 'sync',
  ));
}
```

#### 4. Advanced Data Models
```dart
// Example collections in InstantDB NoSQL
Collections:
- 'tasks': Individual task documents
- 'projects': Project containers with metadata
- 'teams': Team information and member lists
- 'activity': Activity logs and audit trails
- 'templates': Task and project templates
- 'notifications': User notification preferences
- 'integrations': Third-party service connections

// Example task document structure:
{
  "id": "task_123",
  "title": "Implement user authentication",
  "description": "Add biometric auth support",
  "status": "in_progress",
  "priority": "high",
  "assignee": "user_456",
  "project_id": "project_789",
  "due_date": "2025-08-15T14:00:00Z",
  "tags": ["auth", "security", "mobile"],
  "attachments": [...],
  "comments": [...],
  "time_tracked": 7200, // seconds
  "created_at": "2025-08-06T10:00:00Z",
  "updated_at": "2025-08-06T14:30:00Z"
}
```

#### 5. Real-world Workflow Examples
```dart
// Automated workflows in TaskFlow Pro
class TaskWorkflows {
  static final overdueMaintenance = Workflow(
    name: 'Overdue Task Maintenance',
    trigger: ScheduleTrigger(cron: '0 9 * * *'), // Daily at 9 AM
    actions: [
      NotifyAssigneesAction(),
      UpdateTaskPriorityAction(newPriority: Priority.urgent),
      LogActivityAction('Task marked as overdue'),
    ],
  );
  
  static final teamNotification = Workflow(
    name: 'Team Task Assignment',
    trigger: DataChangeTrigger(
      collection: 'tasks',
      field: 'assignee',
      condition: (oldValue, newValue) => newValue != null,
    ),
    actions: [
      SendNotificationAction(
        template: 'You have been assigned task: {{task.title}}',
        recipient: '{{task.assignee}}',
      ),
      AddToCalendarAction(),
    ],
  );
}
```

### Repository Structure

```
taskflow_pro_example/
â”œâ”€â”€ README.md
â”œâ”€â”€ pubspec.yaml
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ main.dart                    # App shell initialization
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”œâ”€â”€ app_config.dart         # Shell configuration
â”‚   â”‚   â”œâ”€â”€ instantdb_config.dart   # InstantDB setup
â”‚   â”‚   â””â”€â”€ wizard_config.dart      # Onboarding flow
â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â”œâ”€â”€ onboarding/            # Wizard screens
â”‚   â”‚   â”œâ”€â”€ tasks/                 # Task management
â”‚   â”‚   â”œâ”€â”€ projects/              # Project views
â”‚   â”‚   â”œâ”€â”€ team/                  # Collaboration features
â”‚   â”‚   â””â”€â”€ analytics/             # Productivity stats
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ task_service.dart      # Custom business logic
â”‚   â”‚   â”œâ”€â”€ project_service.dart   # Project management
â”‚   â”‚   â””â”€â”€ team_service.dart      # Team collaboration
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ task.dart
â”‚   â”‚   â”œâ”€â”€ project.dart
â”‚   â”‚   â””â”€â”€ team.dart
â”‚   â””â”€â”€ widgets/
â”‚       â”œâ”€â”€ task_card.dart
â”‚       â”œâ”€â”€ project_header.dart
â”‚       â””â”€â”€ team_avatar.dart
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ SETUP.md                   # Getting started guide
â”‚   â”œâ”€â”€ FEATURES.md                # Feature documentation
â”‚   â”œâ”€â”€ CUSTOMIZATION.md           # Customization guide
â”‚   â””â”€â”€ screenshots/               # App screenshots
â””â”€â”€ instantdb/
    â”œâ”€â”€ migrations/                # Database setup
    â””â”€â”€ functions/                 # Edge functions
```

### Documentation Examples

#### Quick Start Guide
```markdown
# TaskFlow Pro Example App

## ğŸš€ Quick Start

1. Clone the repository
2. Configure InstantDB credentials in `.env` file and `lib/config/instantdb_config.dart`
3. Run `flutter pub get`
4. Run `flutter run`

## ğŸ¯ What You'll Learn

- âœ… How to set up the Application Shell in 5 minutes
- âœ… Implementing wizard-based onboarding
- âœ… Multi-UI system support (Material/Cupertino/Custom)
- âœ… Real-time collaboration with InstantDB
- âœ… Offline-first data sync with conflict resolution
- âœ… Advanced settings management
- âœ… Custom service integration
- âœ… Responsive layout implementation

## ğŸ“‹ Features Demonstrated

### Core Shell Features
- [x] Zero-config app initialization
- [x] Adaptive navigation (tabs â†’ rail â†’ sidebar)
- [x] Auto-generated settings page
- [x] Wizard navigation for onboarding
- [x] Multi-UI system switching
- [x] InstantDB authentication & sync
- [x] Offline-first data handling

### Advanced Features  
- [x] Real-time collaboration
- [x] Global search functionality
- [x] Keyboard shortcuts
- [x] Data export/import
- [x] Workflow automation
- [x] Team management
- [x] Analytics dashboard
```

### Video Tutorial Series Plan

1. **Episode 1**: "Zero to App in 5 Minutes" - Basic shell setup
2. **Episode 2**: "Beautiful Onboarding" - Wizard implementation
3. **Episode 3**: "Multi-Platform UI" - UI system switching
4. **Episode 4**: "Cloud-Powered" - InstantDB integration
5. **Episode 5**: "Offline-First" - Data sync and conflicts
6. **Episode 6**: "Power User Features" - Advanced customization
7. **Episode 7**: "Team Collaboration" - Real-time features
8. **Episode 8**: "Production Ready" - Deployment and monitoring

### Additional Repository Assets

#### Interactive Demo
- **Web demo** hosted on GitHub Pages
- **QR codes** for mobile testing
- **Feature toggles** to show/hide shell features
- **Live configuration** panel to modify shell behavior

#### Code Examples
- **Snippet library** for common patterns
- **Migration guides** from popular frameworks
- **Integration examples** with popular packages
- **Performance benchmarks** and optimization tips

This comprehensive example would serve as both a learning tool and a production-ready starting point for developers wanting to use the Application Shell framework!

## Technical Considerations
- Lazy loading of non-critical services
- Memory management for signals
- Efficient widget rebuilding
- Bundle size optimization strategies

### Testing
- Unit tests for all services
- Integration tests for service interactions
- Widget tests for UI components
- End-to-end testing framework

### Documentation
- API documentation
- Usage examples
- Migration guides
- Best practices guide

### Maintenance
- Regular dependency updates
- Performance monitoring
- Community feedback integration
- Long-term support strategy

---

## Quick Reference for AI Development

### Basic App Setup
```dart
import 'package:flutter_app_shell/flutter_app_shell.dart';

void main() {
  runShellApp(() async {
    return AppConfig(
      title: 'My App',
      routes: [
        AppRoute(
          title: 'Home',
          path: '/',
          icon: Icons.home,
          builder: (context, state) => HomeScreen(),
        ),
      ],
    );
  });
}
```

### Using Services
```dart
// Get service from dependency injection
final db = getIt<DatabaseService>();
final auth = getIt<AuthenticationService>();

// Create reactive data
await db.create('todos', {
  'title': 'Buy groceries',
  'completed': false,
});

// Watch for changes
db.watchByType('todos').listen((documents) {
  print('Todos updated: ${documents.length}');
});
```

### Adaptive UI Pattern
```dart
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final ui = getAdaptiveFactory(context);
    
    return ui.scaffold(
      body: Column(
        children: [
          ui.button(
            label: 'Adaptive Button',
            onPressed: () {},
          ),
          ui.textField(
            labelText: 'Adaptive Input',
            onChanged: (value) {},
          ),
        ],
      ),
    );
  }
}
```

### Reactive State with Signals
```dart
// Create reactive state
final counter = signal(0);

// Watch in UI (automatically rebuilds)
Watch((context) => Text('Count: ${counter.value}'))

// Update from anywhere
counter.value++;
```

### Key Patterns to Follow
1. **Always use adaptive factory**: `getAdaptiveFactory(context)` instead of platform-specific widgets
2. **Service-first architecture**: Business logic in services, not widgets
3. **Reactive UI**: Use `Watch()` widgets for automatic updates
4. **Dependency injection**: Access services via `getIt<ServiceType>()`
5. **Offline-first**: Local database with automatic cloud sync

This framework follows Material Design, iOS Human Interface Guidelines, and modern minimalist design principles depending on the selected UI system.

